# 软件开发框架与设计模式实践

## 软件开发原则

### 1. 开闭原则 (OCP)

- **核心思想：** 一个软件实体（如类、模块、函数）应该对**扩展开放**，对**修改关闭**。简单来说，就是当增加新功能时，我们应该通过增加新代码来实现，而不是修改已有的旧代码。

- **生活中的类比：** 你的手机。你可以通过安装新App（扩展）来获得新功能（如外卖、打车），但你不需要“修改”手机的操作系统本身（关闭）。

- **场景分析：一个电商网站的打折计算器**

  - **违反原则的做法 (对修改开放):** 假设我们有一个计算器，根据用户的会员等级打不同的折扣。

    ```java
    // V1.0 版本
    class DiscountCalculator {
        public double calculate(String userType, double price) {
            if ("Normal".equals(userType)) {
                return price * 0.95; // 普通会员95折
            } else if ("VIP".equals(userType)) {
                return price * 0.85; // VIP会员85折
            }
            return price;
        }
    }
    ```

    **问题在哪？** 现在，产品经理要求增加一个“超级VIP”（SVIP）75折的功能。你唯一的办法就是**修改** `calculate` 方法，在里面增加一个 `else if ("SVIP".equals(userType))`。如果未来再增加“节日折扣”、“首单折扣”... 你需要无休止地修改这个类，它会变得越来越臃肿，而且每次修改都有可能引入Bug，影响到原有的逻辑。

  - **遵循原则的做法 (对扩展开放):** 我们不修改计算器，而是将“打折策略”抽象出来，让它可以被“扩展”。

    ```java
    // 步骤1: 创建一个打折策略的“标准”（接口）
    interface DiscountStrategy {
        double applyDiscount(double price);
    }
    
    // 步骤2: 为每种会员创建具体的策略类
    class NormalStrategy implements DiscountStrategy {
        public double applyDiscount(double price) { return price * 0.95; }
    }
    class VipStrategy implements DiscountStrategy {
        public double applyDiscount(double price) { return price * 0.85; }
    }
    
    // 步骤3: 计算器只负责使用策略，不关心具体策略是什么
    class DiscountCalculator {
        public double calculate(DiscountStrategy strategy, double price) {
            return strategy.applyDiscount(price);
        }
    }
    
    // 现在，要增加 SVIP 功能，只需要“新增”一个类即可，完全不用碰旧代码！
    class S_VipStrategy implements DiscountStrategy {
        public double applyDiscount(double price) { return price * 0.75; }
    }
    ```

- **我们为什么要遵循它？**

  - **提高稳定性：** 不修改旧代码，就不会给现有稳定运行的功能引入新的Bug。
  - **提高可维护性：** 功能之间是独立的，新人接手项目时，只需要关注新增的策略类，而不用去读懂那个巨大的 `if-else` 怪兽。
  - **增强灵活性和可扩展性：** 需求变化时，我们能像搭积木一样增加新功能，而不是对旧积木进行危险的改造。



### 2. 里氏替换原则 (LSP)

- **核心思想：** 所有引用基类（父类）的地方，必须能透明地使用其子类的对象，而程序行为不发生改变。也就是说，**子类必须能够完全替代它的父类**。

- **生活中的类比：** 你有一个玩具遥控器，它可以控制“遥控车”（父类）。那么，任何一款新型的遥控车（子类），比如“遥控跑车”或“遥控卡车”，都应该能被这个遥控器完美控制。如果某款“遥控飞机”（错误的子类）虽然也能被遥控，但按“前进”它却“向上飞”，这就违反了里氏替换原则。

- **场景分析：正方形是不是一个长方形？** 这是最经典的例子。从数学上看，正方形是一种特殊的长方形。我们尝试用继承来实现。

  - **违反原则的做法：**

    ```java
    class Rectangle { // 长方形
        protected double width;
        protected double height;
        public void setWidth(double w) { this.width = w; }
        public void setHeight(double h) { this.height = h; }
        public double getArea() { return width * height; }
    }
    
    class Square extends Rectangle { // 正方形继承长方形
        @Override
        public void setWidth(double w) {
            this.width = w;
            this.height = w; // 因为是正方形，所以宽和高必须相等
        }
        @Override
        public void setHeight(double h) {
            this.width = h;
            this.height = h; // 同样，设置高也要同时改宽
        }
    }
    
    // 测试代码
    public void test(Rectangle r) {
        r.setWidth(5);
        r.setHeight(4);
        // 按照父类的预期，面积应该是 5 * 4 = 20
        System.out.println("面积是: " + r.getArea());
    }
    
    // 调用
    test(new Square()); // 把子类替换父类传入
    ```

    **问题在哪？** 当我们把一个 `Square` 对象传给 `test` 方法时，`r.setWidth(5)` 后，宽高都变成了5。接着 `r.setHeight(4)` 后，宽高又都变成了4。最终计算出的面积是 `4 * 4 = 16`，而不是预期的 `20`！子类 `Square` 改变了父类 `Rectangle` 的行为约定，导致程序出现意外错误。`Square` 不能完全替换 `Rectangle`。

  - **遵循原则的做法：** 重新审视关系，它们不应该是继承关系。可以创建一个更抽象的 `Shape` (形状) 接口，让它们各自实现。

- **我们为什么要遵循它？**

  - **保证程序的正确性：** 它是实现开闭原则的重要方式之一。只有当子类可以安全替换父类时，我们才能放心地对系统进行扩展。
  - **代码的健壮性：** 避免在使用继承时，出现难以预料的、隐藏的逻辑错误。



### 3. 依赖倒转原则 (DIP)

- **核心思想：** 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。说白了就是，**要面向接口编程，而不是面向实现编程**。 （这个原则和你之前问的“依赖注入”是紧密相连的，依赖注入是实现依赖倒转的一种最常见方式。）

- **生活中的类比：** 你想给你的电脑充电。你关心的只是找到一个“国标两孔插座”（抽象/接口），你不会关心墙壁后面的电线是哪个牌子的、怎么走的（细节/实现）。你的电脑（高层模块）依赖于插座标准（抽象），而不是墙内具体的电线（低层模块）。

- **场景分析：司机开车**

  - **违反原则的做法：**

    ```java
    class BenzCar {
        public void run() { System.out.println("奔驰车在跑..."); }
    }
    
    class Driver { // 司机（高层模块）
        // 司机直接依赖于一个具体的“奔驰车”类（低层模块）
        public void drive(BenzCar car) {
            car.run();
        }
    }
    ```

    **问题在哪？** 这个司机只会开奔驰。如果明天公司给他换了一辆宝马(`BmwCar`)，他就傻眼了。必须修改 `Driver` 类的代码，把 `drive(BenzCar car)` 改成 `drive(BmwCar car)`。高层模块被低层模块牢牢绑定。

  - **遵循原则的做法：** 司机不应该关心具体是什么车，只应该关心“车”这个抽象概念。

    ```java
    // 步骤1: 定义一个“车”的抽象标准（接口）
    interface ICar {
        void run();
    }
    
    // 步骤2: 各种车都来实现这个标准
    class BenzCar implements ICar {
        public void run() { System.out.println("奔驰车在跑..."); }
    }
    class BmwCar implements ICar {
        public void run() { System.out.println("宝马车在跑..."); }
    }
    
    // 步骤3: 司机只依赖于“车”这个标准
    class Driver {
        public void drive(ICar car) { // 依赖于抽象接口 ICar
            car.run();
        }
    }
    ```

- **我们为什么要遵循它？**

  - **实现真正的解耦：** 这是实现解耦最核心的原则。高层策略和低层实现分离开，双方都可以独立变化，互不影响。
  - **提高系统的灵活性和可扩展性：** 只要是符合“车”这个标准的，都可以被司机开走。系统可以轻松地接入新的实现，比如 `AudiCar`。



### 4. 接口隔离原则 (ISP)

- **核心思想：** 客户端不应该被强迫依赖于它们不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上。简单说，就是**接口要小而专，不要大而全**。

- **生活中的类比：** 一个多功能一体机（打印、扫描、复印、传真）。你只是想用它的“扫描”功能，但你却不得不面对一个拥有几十个按钮和复杂菜单的面板。如果它能提供一个独立的“扫描仪”面板，上面只有“扫描”和“设置”两个按钮，对你来说会清晰得多。

- **场景分析：智能安全门**

  - **违反原则的做法：** 我们设计一个巨大的、无所不包的 `ISmartDoor` 接口。

    ```java
    interface ISmartDoor {
        void lock();
        void unlock();
        void alarm();  // 报警功能
        void talk();   // 对讲功能
    }
    
    // 一个普通的、只有基础功能的门来实现这个接口
    class SimpleDoor implements ISmartDoor {
        public void lock() { /* ... */ }
        public void unlock() { /* ... */ }
        // 问题来了：这个门根本没有报警和对讲功能，但被迫要实现这两个方法
        public void alarm() { /* 空着，或者抛出异常 */ }
        public void talk() { /* 空着，或者抛出异常 */ }
    }
    ```

    **问题在哪？** `SimpleDoor` 被迫实现了它根本不需要的功能，造成了代码的臃肿和误解。使用这个门的人（客户端）也会看到 `alarm` 和 `talk` 方法，可能会误用它们。

  - **遵循原则的做法：** 将大接口拆分成多个小而专的接口。

    ```java
    interface ILockable { // 可上锁接口
        void lock();
        void unlock();
    }
    interface IAlarmable { // 可报警接口
        void alarm();
    }
    interface ITalkable { // 可对讲接口
        void talk();
    }
    
    // SimpleDoor 只实现它需要的功能
    class SimpleDoor implements ILockable {
        public void lock() { /* ... */ }
        public void unlock() { /* ... */ }
    }
    
    // 高级门可以实现多个接口
    class AdvancedDoor implements ILockable, IAlarmable, ITalkable {
        // ... 实现所有接口的方法
    }
    ```

- **我们为什么要遵循它？**

  - **降低耦合度：** 客户端只需知道它关心的方法，而不是整个大而全的接口。
  - **提高内聚度：** 接口的功能更专一，职责更清晰。
  - **提高代码的可读性和可维护性：** 代码更清晰，不会出现大量无用的空方法。



### 5. 合成复用原则 (CRP)

- **核心思想：** 尽量使用对象组合（Composition/Aggregation），而不是继承来达到复用的目的。即**“多用组合，少用继承”**。

- **生活中的类比：** 组装电脑。你想给电脑增加“蓝牙功能”和“独立显卡”。你不会去“继承”一台带蓝牙的电脑，而是会买一个“蓝牙模块”（一个对象）和一个“显卡”（另一个对象），然后把它们“组合”到你的电脑主板上。

- **场景分析：机器人添加功能**

  - **倾向于继承的做法 (不推荐):**

    ```java
    class Robot {
        public void move() { /* ... */ }
    }
    class CleaningRobot extends Robot {
        public void clean() { /* ... */ }
    }
    class CookingRobot extends Robot {
        public void cook() { /* ... */ }
    }
    ```

    **问题在哪？** 继承是一种非常强的“is-a”关系，非常僵化。如果我现在想要一个“既能打扫又能做饭的机器人”怎么办？Java不支持多重继承，你没法 `extends CleaningRobot, CookingRobot`。你只能创建一个新的 `CleaningAndCookingRobot` 类，然后把 `clean` 和 `cook` 的代码复制一遍，造成代码重复。

  - **遵循原则的做法 (使用组合):** 我们不认为机器人“是”一个打扫者，而是认为机器人“拥有”打扫的能力。

    ```java
    // 把能力定义成独立的类
    class CleaningAbility {
        public void clean() { System.out.println("开始打扫"); }
    }
    class CookingAbility {
        public void cook() { System.out.println("开始做饭"); }
    }
    
    // 机器人“拥有”这些能力
    class Robot {
        private CleaningAbility cleanAbility; // 组合了一个打扫能力对象
        private CookingAbility cookAbility;   // 组合了一个做饭能力对象
    
        // 通过setter注入或构造函数注入来赋予能力
        public void setCleanAbility(CleaningAbility ability) { this.cleanAbility = ability; }
        public void setCookAbility(CookingAbility ability) { this.cookAbility = ability; }
    
        public void clean() {
            if (cleanAbility != null) cleanAbility.clean();
        }
        public void cook() {
            if (cookAbility != null) cookAbility.cook();
        }
    }
    ```

    **好处在哪？** 现在我们可以非常灵活地给机器人赋予各种能力。想让它能打扫，就给它注入一个 `CleaningAbility` 对象。想让它又能做饭，再注入一个 `CookingAbility` 对象。非常灵活，就像插拔模块一样。

- **我们为什么要遵循它？**

  - **极高的灵活性：** 组合关系比继承关系弱得多，可以动态地组合不同的功能。
  - **降低耦合度：** 类与类之间的依赖关系更松散。
  - **避免继承体系的爆炸和僵化：** 可以有效地避免因功能组合而导致类数量急剧增加的问题。



### 6. 迪米特法则 (LoD)

- **核心思想：** 一个对象应该对其他对象有最少的了解。通俗地讲，就是**只和你的直接朋友交谈，不要和陌生人说话**。

- **生活中的类比：** 你去公司找老板报销。你只需要把发票给你的“直接朋友”——你的部门经理。然后由你的部门经理去和财务部门的经理（他的直接朋友）沟通。你不需要，也不应该越过你的经理，直接跑去和财务部的某个员工（陌生人）说：“快给我报销”。

- **场景分析：学生让班长交班费**

  - **违反原则的做法：**

    ```java
    class Teacher {
        // 老师让班长通知收班费
        public void command(GroupLeader leader) {
            // ...
        }
    }
    class GroupLeader {
        private List<Student> students;
        public List<Student> getStudents() { return this.students; }
    }
    class Student {
        public void pay() { System.out.println("交班费"); }
    }
    
    // 调用端（比如辅导员）
    class Counselor {
        public void collectFee(Teacher teacher, GroupLeader leader) {
            // 辅导员为了让学生交钱，竟然要先从班长那里拿到所有学生的列表，
            // 然后自己一个一个去命令学生交钱。
            // 这就和“陌生人”Student类产生了直接的交互。
            List<Student> students = leader.getStudents();
            for (Student s : students) {
                s.pay();
            }
        }
    }
    ```

    **问题在哪？** `Counselor` (辅导员)为了完成任务，了解了太多不该他知道的细节（`GroupLeader` 内部有 `Student` 列表）。如果有一天 `GroupLeader` 内部不再用 `List<Student>` 来管理学生，而是换成了 `Map<String, Student>`，那么 `Counselor` 的代码就必须修改。

  - **遵循原则的做法：** `Counselor` 只需要向他的“直接朋友” `GroupLeader` 下达指令即可，具体怎么做是 `GroupLeader` 自己的事。

    ```java
    class GroupLeader {
        private List<Student> students;
        // 提供一个任务方法，而不是暴露内部细节
        public void collectFee() {
            for (Student s : students) {
                s.pay();
            }
        }
    }
    
    // 调用端（辅导员）
    class Counselor {
        public void collectFee(Teacher teacher, GroupLeader leader) {
            // 现在，辅导员只和他的直接朋友 GroupLeader 说话
            leader.collectFee();
        }
    }
    ```

- **我们为什么要遵循它？**

  - **降低类之间的耦合度：** 每个类都封装好自己的内部实现，不暴露给外界。
  - **提高模块的独立性：** 当一个模块的内部实现改变时，不会波及到其他模块。
  - **增强代码的可维护性：** 系统的结构更清晰，每个类的责任都更明确。



<span style="color:#FF0000; font-weight:bold;">面向对象语言 “多态” 的实际底层实现</span>

## UML类图

### UML关联多重度

UML图中关联的多重度指：一个类的实例能够与另一个类的多少个实例相关联

![blob.png](https://cslabcg.whu.edu.cn/cguserImages?_img=c10656a36361a9f8267489cd033daa42.png)

(1) 1..1; (2) 0..; (3) 1..1; (4) 1..1; (5) 1..1; (6) 1..。

### 核心区别速览

| 关系名称                  | 核心思想 / 语义              | 关系强度      | 生命周期         | 连接对象           | 代码体现                     | UML符号                |
| ------------------------- | ---------------------------- | ------------- | ---------------- | ------------------ | ---------------------------- | ---------------------- |
| **泛化** (Generalization) | **is-a (是一个)**            | 继承耦合 (强) | -                | 类与类 接口与接口  | `extends`                    | `—◁` (实线空心三角)    |
| **实现** (Realization)    | **can-do (能做)**            | 契约耦合 (中) | -                | 类与接口           | `implements`                 | `- - ◁` (虚线空心三角) |
| **依赖** (Dependency)     | **uses-a (使用一个)**        | **最弱**      | 完全独立         | 类与类             | 方法参数、局部变量           | `- - >` (虚线箭头)     |
| **关联** (Association)    | **has-a (拥有一个)**         | 弱            | 独立             | 类与类             | 成员变量                     | `—>` (实线箭头)        |
| **聚合** (Aggregation)    | **is-part-of (是...一部分)** | 中            | 独立             | 类与类 (整体-部分) | 成员变量                     | `◇—` (空心菱形)        |
| **组合** (Composition)    | **contains-a (包含一个)**    | **最强**      | **生命周期共存** | 类与类 (整体-部分) | 成员变量 (整体负责创建/销毁) | `◆—` (实心菱形)        |

### 1. 泛化关系 (Generalization)

泛化关系描述的是一种“一般”与“特殊”之间的关系，也就是我们常说的父子类关系或继承关系。一个子类（特殊类）继承了父类（一般类）的所有属性和行为，并可以添加自己特有的属性和行为，或者重写父类的行为。

- **核心思想**: **"is-a" (是一个)**。例如，“小汽车” **是** “一种交通工具”。
- **关键字**: 在Java、C#等语言中，通常用 `extends` 或冒号 `:` 来表示。
- **特点**:
  - 这是一种类与类之间的关系。
  - 子类自动拥有父类的非私有属性和方法，实现了代码复用。
  - 它体现了面向对象中从一般到特殊的层次结构。
  - 在大多数编程语言中（如Java、C#），类只支持**单继承**，即一个子类只能有一个直接父类。
- **比喻**: **交通工具 (Vehicle)**。
  - `交通工具`是父类，它有“速度(speed)”属性和“移动(move)”方法。
  - `小汽车(Car)`和`自行车(Bicycle)`都是`交通工具`的子类。它们都继承了“速度”和“移动”的特性。
  - 同时，`小汽车`有自己独特的“引擎(engine)”，`自行车`有自己独特的“脚踏板(pedal)”。
- **UML符号**: 一条**实线**，末端带一个**空心三角箭头**，箭头指向**父类**。

**代码示例 (Java)**:

```java
// 父类 (一般类)
abstract class Vehicle {
    protected int speed;

    public void move() {
        System.out.println("交通工具在移动。");
    }
}

// 子类 (特殊类)
class Car extends Vehicle {
    private String engineType;

    // 重写父类方法
    @Override
    public void move() {
        System.out.println("小汽车在公路上飞驰。");
    }

    public void honk() {
        System.out.println("滴滴！");
    }
}
```

**UML图示**:

```
@startuml
abstract class Vehicle {
  # speed: int
  + move()
}
class Car {
  - engineType: String
  + move()
  + honk()
}
Vehicle <|-- Car
@enduml
```



### 2. 实现关系 (Realization)

实现关系描述的是一个**类**去实现一个**接口 (Interface)** 的所有功能。接口本身只定义了一组行为（方法签名），但没有提供任何具体实现。实现该接口的类必须为这些行为提供具体的实现方式。

- **核心思想**: **"can-do" (能做)** 或 **"implements-a" (实现一个)**。例如，“鸟” **能** “飞”，“飞机”也**能**“飞”。
- **关键字**: 在Java、C#等语言中，通常用 `implements` 或冒号 `:` 来表示。
- **特点**:
  - 这通常是类与接口之间的关系。
  - 它是一种“契约”关系，类承诺实现接口中定义的所有方法。
  - 一个类可以**实现多个接口**，从而获得多种“能力”。这弥补了单继承的不足。
  - 它强制实现了不同类之间的行为规范，是实现多态的重要手段。
- **比喻**: **飞行的能力 (Flyable)**。
  - `Flyable`是一个接口，它定义了一个“飞(fly)”的行为契约。
  - `鸟(Bird)`和`飞机(Airplane)`是两个完全不同的事物，但它们都**能**“飞”，所以它们都可以去实现`Flyable`接口。
  - `鸟`有自己的飞行方式（扇动翅膀），`飞机`也有自己的飞行方式（依靠引擎），它们各自提供了`fly`方法的具体实现。
- **UML符号**: 一条**虚线**，末端带一个**空心三角箭头**，箭头指向**接口**。

**代码示例 (Java)**:

```java
// 接口 (定义契约)
interface Flyable {
    void fly(); // 接口中方法默认是 public abstract
}

// 实现类1
class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("鸟在扇动翅膀飞翔。");
    }
}

// 实现类2
class Airplane implements Flyable {
    @Override
    public void fly() {
        System.out.println("飞机依靠引擎在空中飞行。");
    }
}
```

**UML图示**:

```
@startuml
interface Flyable {
  + fly()
}
class Bird
class Airplane
Flyable <|.. Bird
Flyable <|.. Airplane
@enduml
```



### 3. 依赖关系 (Dependency)

这是最弱的一种关系，表示一个类（A）在某个方法中需要使用到另一个类（B）的对象，但这种使用是**临时性**的、**短暂**的。

- **核心思想**: "uses-a" (使用)
- **生命周期**: 两个对象的生命周期完全独立。类A的方法执行完后，通常就不会再持有类B对象的引用。
- **特点**:
  - 是一种临时性的、局部的关系。
  - 如果类B发生变化，可能会影响到类A。
- **代码体现**: 通常表现为方法参数、方法内的局部变量，或者对静态方法的调用。
- **比喻**: **人(Person) 与 汽车(Car)**。一个人可以**驾驶**一辆车。这个人并不拥有这辆车，只是在“驾驶”这个动作（方法）中临时使用它。车可以是租来的，也可以是朋友的。驾驶结束后，人与这辆车的特定关系就结束了。

**UML 图示**:

```
@startuml
class Person {
  drive(car: Car)
}
class Car {}
Person ..> Car : uses
@enduml
```

**代码示例**:

```java
class Car {
    public void run() {
        System.out.println("汽车在行驶...");
    }
}

class Person {
    // Car对象作为方法参数传入，Person类不持有Car的引用作为成员变量
    public void drive(Car car) {
        System.out.println("人开始驾驶。");
        car.run();
    }
}
```



### 4. 关联关系 (Association)

关联关系描述了不同类的对象之间存在的**长期**、**结构化**的联系。

- **核心思想**: "has-a" (拥有)
- **生命周期**: 两个对象的生命周期相互独立。谁也不会因为对方的销毁而销毁。
- **特点**:
  - 比依赖关系更强，是一种结构化的关系。
  - 可以是双向的，也可以是单向的。
  - 有关联的对象之间通常是“平级”的。
- **代码体现**: 通常表现为一个类将另一个类的对象作为其**成员变量**。
- **比喻**: **老师(Teacher) 与 学生(Student)**。一个老师可以教多个学生，一个学生也可以被多个老师教。他们之间存在一种“教学”关系。当一个老师离职时，学生仍然存在；当一个学生毕业时，老师也还在。

**UML 图示**:

```
@startuml
class Teacher {
  -students: List<Student>
}
class Student {}
' "1" 表示一个老师, "*" 表示多个学生
Teacher "1" -- "*" Student
@enduml
```

**代码示例**:

```java
import java.util.List;

class Student {
    private String name;
    // ...
}

class Teacher {
    private String name;
    // Teacher类拥有一个Student列表的引用作为成员变量
    private List<Student> students;
    // ...
}
```



### 5. 聚合关系 (Aggregation)

聚合是关联关系的一种**特例**，它体现的是一种**整体与部分 (whole-part)** 的关系。部分可以脱离整体而独立存在。

- **核心思想**: "has-a" (拥有)，并且是整体与部分的关系。
- **生命周期**: 部分的生命周期**独立于**整体。即使整体被销毁，部分依然可以存在。
- **特点**:
  - 是一种相对松散的“包含”关系。
  - 部分对象可以被多个整体对象共享。
- **代码体现**: 与关联类似，一个类拥有另一个类的对象作为成员变量。但逻辑上，整体负责“聚合”部分，但通常不负责创建和销毁部分。
- **比喻**: **电脑(Computer) 与 鼠标(Mouse)、键盘(Keyboard)**。电脑是一个整体，鼠标和键盘是它的组成部分。但是，鼠标和键盘可以独立于电脑存在。你可以把鼠标拔下来给另一台电脑用，即使电脑坏了，鼠标和键盘也还是好的。

**UML 图示**: (空心菱形指向整体)

```
@startuml
class Computer {}
class Mouse {}
' 空心菱形在整体一端
Computer o-- Mouse
@enduml
```

**代码示例**:

```java
class Mouse {
    private String brand;
    public Mouse(String brand) { this.brand = brand; }
}

class Computer {
    // Mouse对象通过构造函数或setter传入，Computer不负责创建Mouse
    private Mouse mouse;

    public void setMouse(Mouse mouse) {
        this.mouse = mouse;
    }
}

// 我们可以独立创建Mouse对象
Mouse myMouse = new Mouse("罗技");
Computer myComputer = new Computer();
myComputer.setMouse(myMouse); // 将已存在的mouse设置给computer
```



### 6. 组合关系 (Composition)

组合是关联关系中**最强**的一种，同样体现了整体与部分的关系，但更加严格。部分**不能**脱离整体而独立存在。

- **核心思想**: "contains-a" (包含)，并且生命周期紧密耦合。
- **生命周期**: 部分的生命周期**依赖于**整体。整体创建时，部分随之创建；整体销毁时，部分随之销毁。
- **特点**:
  - 是一种非常紧密的“包含”关系。
  - 部分对象不能被其他整体对象共享。
  - 整体对部分的生命周期负有全部责任。
- **代码体现**: 整体类通常在其构造函数中直接创建部分类的实例，并将其作为成员变量。
- **比喻**: **人(Human) 与 大脑(Brain)、心脏(Heart)**。大脑和心脏是人体的组成部分。人一旦死亡，其大脑和心脏也随之“死亡”（失去了其作为器官的功能和意义）。大脑不能脱离人而独立存在，也不能被共享给另一个人。

**UML 图示**: (实心菱形指向整体)

```
@startuml
class Human {}
class Heart {}
' 实心菱形在整体一端
Human *-- Heart
@enduml
```

**代码示例**:

```java
class Heart {
    public Heart() {
        System.out.println("心脏被创建。");
    }
    public void beat() {
        System.out.println("心脏在跳动。");
    }
}

class Human {
    // Human类直接负责Heart对象的创建
    private final Heart heart;

    public Human() {
        // 在Human的构造函数中创建Heart，生命周期绑定
        this.heart = new Heart();
        System.out.println("人被创建。");
    }

    public void live() {
        this.heart.beat();
    }
}

// 当human对象被创建时，heart对象也被创建
Human person = new Human();
// 当person对象被垃圾回收时，其拥有的heart对象也会被回收
```



## 依赖注入 DI

假设一个场景，就是：**你想喝一杯咖啡**。

------



### 场景一：没有依赖注入（你自己搞定一切）

假设你是一个咖啡爱好者，你的“任务” (`Task`) 是“喝咖啡”。为了完成这个任务，你需要一杯咖啡 (`Coffee`)。

在这种模式下，你 (对象 `You`) 需要亲自负责制作咖啡的每一个环节。

**代码会是这样：**

```java
// 这是咖啡豆
class CoffeeBean {
    public String getName() { return "哥伦比亚咖啡豆"; }
}

// 这是水
class Water {
    public int getTemperature() { return 95; }
}

// 这是咖啡的“具体实现”
class AmericanoCoffee {
    private CoffeeBean bean;
    private Water water;

    // 为了制作美式咖啡，你必须自己准备好豆子和水
    public AmericanoCoffee() {
        this.bean = new CoffeeBean(); // 自己找豆子
        this.water = new Water();     // 自己烧水
        System.out.println("成功制作了一杯美式咖啡，使用了：" + bean.getName());
    }

    public void drink() {
        System.out.println("开始喝咖啡...");
    }
}

// 这是“你”这个类
class You {
    private AmericanoCoffee coffee;

    public void startYourDay() {
        System.out.println("新的一天，想喝咖啡了。");
        // 你决定“自己动手”做一杯美式咖啡
        this.coffee = new AmericanoCoffee();
        coffee.drink();
    }
}
```

**现在分析一下问题在哪里：**

1. **缺乏灵活性（耦合太紧）**: `You` 这个类和 `AmericanoCoffee` 这个具体实现“焊死”了。明天你突然想喝拿铁 (`LatteCoffee`) 怎么办？你必须修改 `You` 类的代码，把 `new AmericanoCoffee()` 改成 `new LatteCoffee()`。如果后天想喝卡布奇诺呢？又要改！你的“喝咖啡”这个行为，严重依赖于具体的咖啡种类。
2. **难以测试**: 假设你想测试一下 `You` 这个类在“没有咖啡”的情况下会怎么样。做不到！因为 `You` 类只要一执行 `startYourDay`，就一定会去 `new` 一个 `AmericanoCoffee`，你无法在测试时把咖啡拿走。

------



### 场景二：使用依赖注入（让咖啡店员为你服务）

现在，我们换一种方式。你不再关心咖啡是怎么做出来的，你只关心“我需要一杯咖啡”。你家楼下开了一家咖啡店（这就是**DI容器**），店里有专业的咖啡师。

你的角色变了：从一个“制作者”变成了一个“消费者”。

**代码会是这样：**

**第1步：定义标准（接口）**

首先，我们定义一个“咖啡”的通用标准（接口），所有咖啡都必须遵守这个标准。

```java
// 这是一个“咖啡”的通用接口
interface Coffee {
    void drink();
}
```

**第2步：制作各种具体的咖啡**

咖啡师可以根据这个标准制作各种咖啡。

```java
// 美式咖啡的具体实现
class AmericanoCoffee implements Coffee {
    public AmericanoCoffee() {
        System.out.println("一杯美式咖啡做好了。");
    }
    @Override
    public void drink() {
        System.out.println("喝美式咖啡，提神醒脑。");
    }
}

// 拿铁咖啡的具体实现
class LatteCoffee implements Coffee {
    public LatteCoffee() {
        System.out.println("一杯拿铁做好了。");
    }
    @Override
    public void drink() {
        System.out.println("喝拿铁，享受丝滑奶泡。");
    }
}
```

**第3步：改造“你”这个类（使用构造函数注入）**

你不再自己制作咖啡，而是在“需要开始新的一天”时，直接接收一杯已经做好的咖啡。

```java
class You {
    // 你只关心你有一杯“符合Coffee标准的东西”，不关心它具体是什么
    // final表示:
    // 变量一旦被赋值，便无法被修改
    // 对象的引用地址不能被改变
    // 方法不能被子类Override
    // 类不能被其他任何类继承
    private final Coffee coffee;

    // **核心：依赖注入**
    // 你的构造函数要求：必须给我一杯咖啡，我才能开始新的一天
    public You(Coffee coffee) {
        this.coffee = coffee; // 咖啡被“注入”进来了
    }

    public void startYourDay() {
        System.out.println("新的一天，咖啡已经准备好了！");
        this.coffee.drink();
    }
}
```

**第4步：咖啡店（DI容器）开始工作**

现在，场景的“启动入口”（比如 `main` 函数）就扮演了咖啡店的角色。它负责决定今天做什么咖啡，并把它“递给你”。

```java
public class CoffeeShop {
    public static void main(String[] args) {
        // --- 今天你想喝美式 ---
        System.out.println("场景A：顾客想喝美式");
        Coffee americano = new AmericanoCoffee(); // 咖啡师（容器）制作美式
        You customer1 = new You(americano);       // 把美式递给（注入）顾客
        customer1.startYourDay();

        System.out.println("\n--------------------------\n");

        // --- 明天你想喝拿铁 ---
        System.out.println("场景B：顾客想喝拿铁");
        Coffee latte = new LatteCoffee();         // 咖啡师（容器）制作拿铁
        You customer2 = new You(latte);           // 把拿铁递给（注入）顾客
        customer2.startYourDay();
    }
}
```

**核心就是一句话：依赖注入将“组件”（你）和它所依赖的服务（咖啡）的“创建”和“绑定”过程，从组件内部移到了外部容器（咖啡店）中。**

通过这个例子，你应该能更具体地感受到依赖注入带来的巨大好处：它让你的代码变得像搭乐高积木一样，每个模块（`You`, `AmericanoCoffee`, `LatteCoffee`）都是独立的、可替换的，可以由一个“装配工”（DI容器）灵活地组合在一起，从而构建出一个健壮、灵活且易于维护的系统。



## 设计模式

创建型模式：工厂方法模式；

结构性模式：适配器模式；

行为型模式：解释器模式，模板方法模式



## 创建型设计模式

我们来详细介绍并比较三种经典的创建型设计模式：简单工厂模式、工厂方法模式和抽象工厂模式。

这三种模式的核心目标都是**将对象的创建（实例化）过程与使用过程解耦**，从而提高代码的灵活性、可维护性和可扩展性。

### 简单工厂模式

简单工厂模式不属于 GOF定义的 23 种设计模式之一，但它应用广泛，是理解另外两种工厂模式的基础。

**核心思想：** 定义一个单独的工厂类，它根据传入的参数来决定应该创建哪一种产品类的实例。客户端不需要知道具体产品的类名，只需要知道参数即可。

**生活中的例子：** 就像一个快餐店的点餐台，你告诉收银员你要“汉堡”还是“薯条”（参数），收银员（工厂）就会通知后厨给你准备相应的产品，你不用关心汉堡和薯条具体是怎么做出来的。

#### 代码示例

假设我们有一个图表库，可以创建不同类型的图表，如折线图（LineChart）和柱状图（BarChart）。

**第一步：定义产品接口和具体产品**

```java
// 1. 抽象产品接口：Chart
interface Chart {
    void display();
}

// 2. 具体产品类：LineChart
class LineChart implements Chart {
    public LineChart() {
        System.out.println("创建了折线图对象！");
    }
    @Override
    public void display() {
        System.out.println("显示折线图。");
    }
}

// 3. 具体产品类：BarChart
class BarChart implements Chart {
    public BarChart() {
        System.out.println("创建了柱状图对象！");
    }
    @Override
    public void display() {
        System.out.println("显示柱状图。");
    }
}
```

**第二步：创建简单工厂类**

```java
// 4. 简单工厂类
class ChartFactory {
    // 静态方法，根据类型字符串创建并返回对应的图表对象
    public static Chart createChart(String type) {
        if ("line".equalsIgnoreCase(type)) {
            return new LineChart();
        } else if ("bar".equalsIgnoreCase(type)) {
            return new BarChart();
        } else {
            System.out.println("不支持的图表类型！");
            return null;
        }
    }
}
```

**第三步：客户端使用**

```java
// 5. 客户端代码
public class Client {
    public static void main(String[] args) {
        // 客户端只需要和工厂类交互，传入想要的类型
        Chart lineChart = ChartFactory.createChart("line");
        if (lineChart != null) {
            lineChart.display();
        }

        Chart barChart = ChartFactory.createChart("bar");
        if (barChart != null) {
            barChart.display();
        }
    }
}
```

#### 优越性分析

1. **责任分离，实现解耦**：客户端（`Client`）只依赖于工厂（`ChartFactory`）和抽象产品（`Chart`），完全不知道具体产品（`LineChart`, `BarChart`）的存在。创建对象的逻辑被封装在工厂类中，如果具体产品的创建过程很复杂（例如需要读取配置文件、初始化依赖等），这个优势会更明显。
2. **简化客户端代码**：客户端只需要调用一个简单的方法并传入参数，就能获得所需的对象，使用起来非常方便。

#### 缺点

简单工厂模式有一个致命的缺点：**违反了开闭原则（Open-Closed Principle）**。当我们需要增加一种新的图表类型（例如饼图 `PieChart`）时，我们必须修改 `ChartFactory` 类的 `createChart` 方法，在 `if-else` 判断中增加一个新的分支。这在大型项目中是不可取的。



### 工厂方法模式

为了解决简单工厂模式违反开闭原则的问题，工厂方法模式应运而生。

**核心思想：** 定义一个用于创建对象的抽象方法（工厂方法），但将这个方法的具体实现延迟到子类中。也就是说，不再有单一的“全能工厂”，而是为每一种产品都提供一个专门的生产工厂。

**生活中的例子：** 现在不是一个快餐店了，而是有很多专门的工厂。比如有一个“汉堡工厂”，它只负责生产汉堡；还有一个“薯条工厂”，它只负责生产薯条。你需要汉堡时，就去找汉堡工厂。

#### 代码示例

我们继续使用图表的例子。

**第一步：产品接口和具体产品（与简单工厂模式相同）**

```java
interface Chart { void display(); }
class LineChart implements Chart { /* ... */ }
class BarChart implements Chart { /* ... */ }
```

**第二步：定义抽象工厂和具体工厂**

```java
// 1. 抽象工厂接口
interface ChartFactory {
    // 定义一个创建图表的抽象方法
    Chart createChart();
}

// 2. 具体的工厂类：折线图工厂
class LineChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        // 只负责创建折线图
        System.out.println("折线图工厂 -> 创建折线图");
        return new LineChart();
    }
}

// 3. 具体的工厂类：柱状图工厂
class BarChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        // 只负责创建柱状图
        System.out.println("柱状图工厂 -> 创建柱状图");
        return new BarChart();
    }
}
```

**第三步：客户端使用**

```java
// 4. 客户端代码
public class Client {
    public static void main(String[] args) {
        // 需要折线图，就找折线图工厂
        ChartFactory lineFactory = new LineChartFactory();
        Chart lineChart = lineFactory.createChart();
        lineChart.display();

        // 需要柱状图，就找柱状图工厂
        ChartFactory barFactory = new BarChartFactory();
        Chart barChart = barFactory.createChart();
        barChart.display();
    }
}
```

#### 优越性分析

1. **完美遵循开闭原则**：这是工厂方法模式最大的优越性。如果现在要增加一种新的产品，比如饼图（`PieChart`），我们只需要：
   - 创建一个新的具体产品类 `PieChart`。
   - 创建一个新的具体工厂类 `PieChartFactory`。
   - 客户端就可以直接使用 `new PieChartFactory()` 来创建饼图，**完全不需要修改任何已有的代码**（无论是抽象工厂还是其他具体工厂）。这使得系统扩展性极佳。
2. **进一步解耦**：不仅将对象的创建和使用解耦，还将“如何创建”的逻辑从一个中心点分散到各个具体的工厂子类中，每个工厂子类只关心一种产品的创建。

#### 缺点

每增加一个产品，就需要增加一个对应的具体工厂类，这会导致系统中的类的数量成倍增加，增加了系统的复杂度和代码量。



### 抽象工厂模式

如果说工厂方法模式是针对一个产品系列的，那么抽象工厂模式就是针对**多个产品族**的。

**核心思想：** 提供一个接口，用于创建**一系列相关或相互依赖的对象**（一个产品族），而无需指定它们具体的类。

**生活中的例子：** 假设你要装修房子，有两种风格：现代风格和古典风格。

- **现代风格（产品族1）** 包含：现代风格的沙发、现代风格的茶几、现代风格的灯。
- **古典风格（产品族2）** 包含：古典风格的沙发、古典风格的茶几、古典风格的灯。

抽象工厂就像一个“家居风格工厂”的规范，它规定任何一个风格工厂都必须能生产“沙发”、“茶几”和“灯”。而具体的“现代家居工厂”和“古典家居工厂”则按照这个规范，生产出对应风格的一整套家具。

#### 代码示例

假设我们的应用需要支持多种操作系统（Windows, macOS）的 UI 风格。每种风格下都有按钮（Button）和文本框（TextField）。

**第一步：定义抽象产品和具体产品**

```java
// 1. 抽象产品：按钮接口
interface Button {
    void display();
}
// 2. 抽象产品：文本框接口
interface TextField {
    void display();
}

// 3. 具体产品：Windows 风格的按钮和文本框
class WindowsButton implements Button {
    @Override
    public void display() { System.out.println("显示 Windows 风格按钮。"); }
}
class WindowsTextField implements TextField {
    @Override
    public void display() { System.out.println("显示 Windows 风格文本框。"); }
}

// 4. 具体产品：macOS 风格的按钮和文本框
class MacOSButton implements Button {
    @Override
    public void display() { System.out.println("显示 macOS 风格按钮。"); }
}
class MacOSTextField implements TextField {
    @Override
    public void display() { System.out.println("显示 macOS 风格文本框。"); }
}
```

**第二步：定义抽象工厂和具体工厂**

```java
// 5. 抽象工厂接口
interface GUIFactory {
    Button createButton();      // 创建按钮
    TextField createTextField(); // 创建文本框
}

// 6. 具体工厂：Windows UI 工厂，负责创建 Windows 族的所有产品
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() { return new WindowsButton(); }
    @Override
    public TextField createTextField() { return new WindowsTextField(); }
}

// 7. 具体工厂：macOS UI 工厂，负责创建 macOS 族的所有产品
class MacOSFactory implements GUIFactory {
    @Override
    public Button createButton() { return new MacOSButton(); }
    @Override
    public TextField createTextField() { return new MacOSTextField(); }
}
```

**第三步：客户端使用**

```java
// 8. 客户端代码
public class Client {
    public static void main(String[] args) {
        // 假设我们现在需要 Windows 风格的 UI
        GUIFactory factory = new WindowsFactory();
        Button button = factory.createButton();
        TextField textField = factory.createTextField();

        button.display();
        textField.display();

        System.out.println("--- 切换到 macOS 风格 ---");
        // 现在只需要切换工厂，就能获得一整套 macOS 风格的 UI
        GUIFactory macFactory = new MacOSFactory();
        Button macButton = macFactory.createButton();
        TextField macTextField = macFactory.createTextField();

        macButton.display();
        macTextField.display();
    }
}
```

#### 优越性分析

1. **隔离具体类**：客户端只与抽象工厂和抽象产品接口打交道，完全不知道具体的实现类（`WindowsButton` 等）。这使得切换整个产品族变得异常容易。如示例所示，从 Windows 风格切换到 macOS 风格，只需要改变一行代码：`new WindowsFactory()` 变为 `new MacOSFactory()`。
2. **保证产品兼容性**：由于一个具体的工厂只生产属于同一个产品族的产品，这就从机制上保证了由这个工厂创建出来的所有产品都是相互匹配、可以协同工作的。你永远不会从 `WindowsFactory` 中得到一个 `MacOSButton`，避免了风格混搭的混乱。
3. **遵循开闭原则（对于产品族）**：当需要增加一个新的产品族（比如 `LinuxFactory`）时，只需要添加新的具体工厂和具体产品类即可，无需修改现有代码。

#### 缺点

**难以扩展新的产品类型**。如果我们要给所有 UI 风格都增加一个新的产品，比如“复选框”（`CheckBox`），那么我们就必须修改抽象工厂 `GUIFactory` 接口，增加一个 `createCheckBox()` 方法。接着，所有实现了 `GUIFactory` 的具体工厂类（`WindowsFactory`, `MacOSFactory`）都必须进行修改。这违反了开闭原则。

------



### 建造者模式

**核心思想：** 将一个**复杂对象**的**构建过程**与它的**最终表示**分离，使得同样的构建过程可以创建出不同的表示。它主要用于解决“一个对象的属性太多，构造函数参数列表过长”以及“对象在构建过程中存在复杂的步骤或依赖关系”的问题。

**生活中的例子：** 去赛百味（Subway）点三明治。你不会直接跟店员说“要一个三明治”，而是会一步步地告诉他：

1. **选择面包类型**（全麦、白面包...）
2. **选择主菜**（鸡肉、牛肉...）
3. **选择蔬菜**（生菜、番茄、黄瓜...）
4. **选择酱料**（蛋黄酱、甜辣酱...）

整个过程，店员（`Director`）指导你（`Client`）使用一个构建流程，配料台（`Builder`）负责一步步地添加材料，最后产出一个完整的三明治（`Product`）。你可以用同样的流程，选择不同的配料，得到完全不同的三明治。

#### 代码示例

模拟组装电脑的例子。

**第一步：定义复杂的产品类 (Product)**

这个类就是我们要构建的最终目标。它的构造函数通常是私有的，强制我们必须通过建造者来创建它。

```java
// 产品类 (Product)
class Computer {
    private String cpu;       // 必需
    private String ram;       // 必需
    private String storage;   // 必需
    private String gpu;       // 可选
    private String powerSupply; // 可选

    // 构造函数是私有的，只能由建造者调用
    protected Computer(String cpu, String ram, String storage, String gpu, String powerSupply) {
        this.cpu = cpu;
        this.ram = ram;
        this.storage = storage;
        this.gpu = gpu;
        this.powerSupply = powerSupply;
    }

    @Override
    public String toString() {
        return "电脑配置详情:\n" +
                "  CPU: " + cpu + "\n" +
                "  内存: " + ram + "\n" +
                "  硬盘: " + storage + "\n" +
                "  显卡: " + (gpu != null ? gpu : "未配置") + "\n" +
                "  电源: " + (powerSupply != null ? powerSupply : "未配置");
    }
}
```

**第二步：创建建造者 (Builder)**

建造者负责“一步一步”地构建复杂对象。我们先定义一个接口，再给出一个具体实现。

```java
// 建造者接口 (Builder)
interface ComputerBuilder {
    ComputerBuilder setCpu(String cpu);
    ComputerBuilder setRam(String ram);
    ComputerBuilder setStorage(String storage);
    ComputerBuilder setGpu(String gpu); // 可选部件
    ComputerBuilder setPowerSupply(String powerSupply); // 可选部件
    Computer build(); // 最后构建并返回产品
}

// 具体建造者 (Concrete Builder)
class ConcreteComputerBuilder implements ComputerBuilder {
    private String cpu;
    private String ram;
    private String storage;
    private String gpu;
    private String powerSupply;

    @Override
    public ComputerBuilder setCpu(String cpu) {
        this.cpu = cpu;
        return this; // 返回自身，以支持链式调用
    }
    @Override
    public ComputerBuilder setRam(String ram) {
        this.ram = ram;
        return this;
    }
    @Override
    public ComputerBuilder setStorage(String storage) {
        this.storage = storage;
        return this;
    }
    @Override
    public ComputerBuilder setGpu(String gpu) {
        this.gpu = gpu;
        return this;
    }
    @Override
    public ComputerBuilder setPowerSupply(String powerSupply) {
        this.powerSupply = powerSupply;
        return this;
    }
    
    @Override
    public Computer build() {
        if (cpu == null || ram == null || storage == null) {
            throw new IllegalStateException("CPU, 内存和硬盘是必需的配置。");
        }
        return new Computer(cpu, ram, storage, gpu, powerSupply);
    }
}
```

**第三步：创建指挥者 (Director)**

指挥者（Director）是可选的，但它非常有用。它封装了构建特定“预设”或“套餐”的复杂流程。

```java
// 指挥者类 (Director)
class ComputerDirector {
    
    // 指挥者知道如何构建一台“标准办公电脑”
    public void constructStandardOfficePC(ComputerBuilder builder) {
        System.out.println("--- 指挥者开始构建【标准办公电脑】---");
        builder.setCpu("Intel Core i5")
               .setRam("16GB DDR4")
               .setStorage("512GB NVMe SSD")
               .setPowerSupply("500W");
        // 注意：办公电脑套餐不配置独立显卡
    }
    
    // 指挥者也可以知道如何构建一台“豪华游戏电脑”
    public void constructLuxuryGamingPC(ComputerBuilder builder) {
        System.out.println("--- 指挥者开始构建【豪华游戏电脑】---");
        builder.setCpu("Intel Core i9")
               .setRam("64GB DDR5")
               .setStorage("4TB NVMe SSD")
               .setGpu("NVIDIA GeForce RTX 4090")
               .setPowerSupply("1200W");
    }
}
```

**第四步：客户端使用**

客户端现在可以通过两种方式来构建电脑：要么自己一步步灵活构建，要么让指挥者一键构建标准套餐。

```java
public class Client {
    public static void main(String[] args) {
        
        // --- 场景一：客户端需要一台【自定义】的电脑 ---
        System.out.println("--- 场景一：客户端自定义电脑配置 ---");
        ComputerBuilder customBuilder = new ConcreteComputerBuilder();
        
        // 客户端自由地、一步步地进行配置
        Computer customPC = customBuilder
                .setCpu("AMD Ryzen 7")
                .setRam("32GB DDR5")
                .setStorage("2TB NVMe SSD")
                .setGpu("NVIDIA GeForce RTX 3070Ti") // 添加了显卡
                .build(); // 最后获取产品

        System.out.println(customPC);
        System.out.println("-------------------------------------\n");
        

        // --- 场景二：客户端需要一台【标准办公电脑】，不想关心细节 ---
        System.out.println("--- 场景二：客户端通过指挥者创建标准电脑 ---");
        ComputerBuilder officePCBuilder = new ConcreteComputerBuilder();
        ComputerDirector director = new ComputerDirector();

        // 1. 客户端调用指挥者
        director.constructStandardOfficePC(officePCBuilder);
        // 2. 从建造者处获取结果
        Computer officePC = officePCBuilder.build();

        System.out.println(officePC);
        System.out.println("-------------------------------------\n");
    }
}
```

#### 优越性分析

1. **精细化控制构建过程**：客户端可以一步一步地调用 `set...` 方法，精确控制对象的每一个部分的创建。
2. **封装与解耦**：将对象的构建过程（在 `Builder` 中）与它的最终表示（在 `Product` 中）分离开来。`Computer` 类只负责存储数据，`Builder` 负责如何组装这些数据。
3. **支持不同配置**：同一个 `ConcreteComputerBuilder` 对象可以被用来创建完全不同的电脑配置，代码复用性高。
4. **提升代码可读性**：使用 `builder.setCpu(...).setRam(...)` 的链式调用，比使用一个拥有十几个参数的构造函数 `new Computer("i5", "16GB", "512GB", null, "500W", ...)` 要清晰得多，尤其是当有很多可选参数时。
5. **封装预设流程（使用Director时）**：指挥者（Director）可以封装一套标准化的构建流程，客户端只需一键调用，即可得到一个符合规范的复杂对象，无需关心构建细节。



### 原型模式 

**核心思想：** 不通过 `new` 关键字来创建对象，而是通过**复制（克隆）**一个已存在的对象（称为“原型”）来创建新的对象。当创建对象的成本很高时（例如，需要复杂的计算或访问数据库），原型模式非常有用。

**生活中的例子：** 细胞分裂。一个细胞（原型）通过分裂可以快速地创造出另一个和自己一模一样的细胞（新对象）。这比从头合成一个新细胞要快得多。另一个例子是复印文件，复印远比重新手写一份要高效。

#### 代码示例

假设我们有一个 `Shape` 对象，创建它需要一些复杂的初始化。我们可以先创建好一个原型，然后通过克隆来快速生成新的 `Shape`。

**第一步：让原型类实现 `Cloneable` 接口**

```java
// 1. 抽象产品类，实现 Cloneable 接口
abstract class Shape implements Cloneable {
    private String id;
    protected String type;

    abstract void draw();

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getType() { return type; }

    // 2. 覆盖 clone() 方法
    @Override
    public Object clone() {
        Object clone = null;
        try {
            clone = super.clone(); // 执行浅拷贝
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }
}

// 3. 具体原型类
class Circle extends Shape {
    public Circle() {
        type = "Circle";
        // 假设这里有一些耗时的初始化操作
        System.out.println("执行了 Circle 的复杂构造过程...");
    }

    @Override
    void draw() {
        System.out.println("画一个圆形。");
    }
}
```

**第二步：使用原型进行克隆**

```java
public class Client {
    public static void main(String[] args) {
        // 1. 创建一个原型对象，这个过程可能很耗时
        Circle originalCircle = new Circle();
        originalCircle.setId("Original");

        System.out.println("\n--- 开始克隆 ---");

        // 2. 通过克隆快速创建新对象，不再执行构造函数
        Circle clonedCircle = (Circle) originalCircle.clone();
        clonedCircle.setId("Cloned_1");

        // 验证一下
        System.out.println("原型对象: " + originalCircle + ", ID: " + originalCircle.getId());
        System.out.println("克隆对象: " + clonedCircle + ", ID: " + clonedCircle.getId());
        System.out.println("两个对象是同一个吗? " + (originalCircle == clonedCircle));

        clonedCircle.draw();
    }
}
```

#### 优越性分析

1. **性能优越**：当创建新对象的成本（时间、资源）很大时，通过克隆一个已有的对象来创建新对象，可以极大地提升性能。如示例所示，`new Circle()` 时会打印构造信息，而 `clone()` 时则不会。
2. **简化对象创建**：原型模式是 `new` 的一个替代方案，它隐藏了对象创建的复杂性，客户端只需要调用 `clone()` 即可。
3. **动态性**：可以在运行时动态地获取一个对象的拷贝。

**注意**：原型模式需要注意 **深拷贝（Deep Copy）** 和 **浅拷贝（Shallow Copy）** 的问题。`super.clone()` 执行的是浅拷贝，只复制基本数据类型和引用地址。如果对象内部包含其他引用对象，需要手动实现深拷贝来复制那些对象，否则多个对象会共享同一个内部对象，可能导致意外的修改。



### 单例模式 

**核心思想：** 保证一个类**有且仅有一个实例**，并提供一个全局访问点来获取这个唯一的实例。

**生活中的例子：** 一个国家的皇帝或总统。在一个时期内，只能有一个皇帝。无论你在哪里，提到“当今皇上”，指的都是同一个人。这个“皇上”就是单例。

#### 代码示例

实现单例模式有多种方式，这里介绍最推荐的一种：**静态内部类（Initialization-on-demand holder）**，它既能保证线程安全，又能实现懒加载。

```java
// 1. 定义单例类
public class Emperor {

    // 2. 将构造函数私有化，防止外部通过 new 来创建实例
    private Emperor() {
        System.out.println("一位新的皇帝诞生了！(这应该只发生一次)");
    }

    // 3. 使用静态内部类来持有单例实例
    // 这个内部类只有在 getInstance() 方法第一次被调用时才会加载，从而实现懒加载
    private static class SingletonHolder {
        // JVM 保证了类加载时的线程安全
        private static final Emperor INSTANCE = new Emperor();
    }

    // 4. 提供一个全局的静态公共方法来获取唯一实例
    public static Emperor getInstance() {
        return SingletonHolder.INSTANCE;
    }

    // 单例的方法
    public void issueDecree() {
        System.out.println("皇帝 " + this.hashCode() + " 下达了圣旨。");
    }
}
```

**客户端使用：**

```java
public class Minister {
    public static void main(String[] args) {
        System.out.println("第一天早朝...");
        Emperor emperor1 = Emperor.getInstance();
        emperor1.issueDecree();

        System.out.println("\n第二天早朝...");
        Emperor emperor2 = Emperor.getInstance();
        emperor2.issueDecree();

        System.out.println("\n第三天早朝...");
        Emperor emperor3 = Emperor.getInstance();
        emperor3.issueDecree();

        // 验证他们是否是同一个皇帝
        System.out.println("\n三次早朝见的是同一个皇帝吗？ " + (emperor1 == emperor2 && emperor2 == emperor3));
    }
}
```

#### 优越性分析

1. **全局唯一实例**：确保了在任何情况下，一个类只有一个实例，这对于像系统配置、日志管理器、数据库连接池等需要全局统一管理资源和状态的场景至关重要，可以避免因多个实例导致的状态不一致或资源浪费。
2. **节约系统资源**：由于只有一个实例，减少了内存开销和系统创建对象的消耗。
3. **懒加载**：静态内部类方式可以实现懒加载，只有在第一次调用 `getInstance()` 时才会创建实例，避免了程序启动时的不必要开销。



## 结构型设计模式

### 适配器模式

**核心思想：** 将一个类的接口转换成客户端所期望的另一个接口。使得原本由于接口不兼容而不能一起工作的类可以协同工作。

**生活中的例子：** 电源适配器或转换插头。你的笔记本电脑插头是美标的（两扁一圆），但你现在在日本，墙上的插座是日标的（两扁）。你无法直接插入。这时你需要一个**转换插头（适配器）**，它的一端可以插入日标插座（`Target`），另一端可以让你插入美标插头（`Adaptee`）。这个转换插头本身不改变电压，只改变接口形式。

#### 代码示例

假设我们有一个播放器 `MediaPlayer` 只能播放 `mp3`。现在我们想让它能播放 `mp4` 和 `vlc` 格式，而这些格式的播放功能由一个第三方库 `AdvancedMediaPlayer` 提供，但它的接口和我们的 `MediaPlayer` 不兼容。

**第一步：定义不兼容的接口和类**

```java
// 1. 我们已有的目标接口
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 2. 第三方库提供的、接口不兼容的类 (Adaptee)
interface AdvancedMediaPlayer {
    void playMp4(String fileName);
    void playVlc(String fileName);
}

class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file. Name: " + fileName);
    }
    @Override
    public void playVlc(String fileName) { /* do nothing */ }
}
```

**第二步：创建适配器** 适配器需要实现我们的 `MediaPlayer` 接口，并在内部持有 `AdvancedMediaPlayer` 的实例。

```java
// 3. 适配器类 (Adapter)
class MediaAdapter implements MediaPlayer {
    AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String audioType) {
        if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player(); // 假设还有 VlcPlayer 等
        }
        // ...可以扩展支持 vlc 等
    }

    @Override
    public void play(String audioType, String fileName) {
        // 在 play 方法内部，将调用适配到高级播放器的方法
        if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}
```

**第三步：在我们的播放器中使用适配器**

```java
// 4. 我们自己的播放器实现
class AudioPlayer implements MediaPlayer {
    MediaAdapter mediaAdapter;

    @Override
    public void play(String audioType, String fileName) {
        // 内置支持播放 mp3
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file. Name: " + fileName);
        }
        // 其他格式通过适配器来播放
        else if (audioType.equalsIgnoreCase("mp4") || audioType.equalsIgnoreCase("vlc")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media. " + audioType + " format not supported");
        }
    }
}
```

**第四步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();

        audioPlayer.play("mp3", "beyond the horizon.mp3");
        // 通过适配器，我们的播放器现在也能播放 mp4 了！
        audioPlayer.play("mp4", "alone.mp4");
        audioPlayer.play("avi", "mind me.avi");
    }
}
```

#### 优越性分析

1. **复用现有代码**：可以在不修改原有代码（比如第三方库 `AdvancedMediaPlayer`）的情况下，使其与我们的系统协同工作，大大提高了代码的复用性。
2. **提高灵活性和透明度**：客户端始终只与目标接口（`MediaPlayer`）交互，完全不知道背后是否存在一个适配器在做转换工作。这使得我们可以轻松地替换或增加新的适配器，而客户端代码不受影响。
3. **解耦**：将目标接口与被适配者解耦，解决了接口不兼容的问题。

#### 类适配器与对象适配器







### 桥接模式

**核心思想：** 将**抽象部分**与它的**实现部分**分离，使它们都可以独立地变化。这里的“抽象”和“实现”不是指 `interface` 和 `class`，而是指两个独立变化的维度。桥接模式通过“组合/聚合”关系替代继承，来降低两个维度之间的耦合。

**生活中的例子：** 遥控器（抽象）和电视机（实现）。

- **变化维度1（抽象部分）：** 遥控器的种类。可以是“基础遥控器”（只有开关和换台），也可以是“智能遥控器”（带语音、带鼠标功能）。
- **变化维度2（实现部分）：** 电视机的品牌。可以是“索尼电视”，也可以是“三星电视”。

如果没有桥接，你可能需要创建 `索尼基础遥控器`、`索尼智能遥控器`、`三星基础遥控器`、`三星智能遥控器`... 类的数量会爆炸。而桥接模式让你只需要一个遥控器（内含一个电视机对象的引用），就可以控制任何品牌的电视。你可以随意更换遥控器，也可以随意更换电视机，两者互不影响。

#### 代码示例

以不同形状（Shape）和不同颜色（Color）为例。形状和颜色是两个独立变化的维度。

**第一步：定义实现部分的接口和实现**

```java
// 1. 实现部分的接口：Color
interface Color {
    String applyColor();
}

// 2. 具体的实现类
class RedColor implements Color {
    @Override
    public String applyColor() { return "红色"; }
}

class BlueColor implements Color {
    @Override
    public String applyColor() { return "蓝色"; }
}
```

**第二步：定义抽象部分，并通过组合“桥接”实现部分**

```java
// 3. 抽象部分的基类：Shape
abstract class Shape {
    // 通过组合关系，桥接了 Color
    protected Color color;

    public Shape(Color color) {
        this.color = color;
    }

    // 抽象方法
    abstract public void draw();
}

// 4. 扩充抽象部分的类
class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("绘制一个" + color.applyColor() + "的圆形。");
    }
}

class Square extends Shape {
    public Square(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("绘制一个" + color.applyColor() + "的正方形。");
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        // 创建一个红色的圆形
        Shape redCircle = new Circle(new RedColor());
        redCircle.draw();

        // 创建一个蓝色的正方形
        Shape blueSquare = new Square(new BlueColor());
        blueSquare.draw();
    }
}
```

#### 优越性分析

1. **分离抽象和实现**：这是最核心的优点。`Shape` 和 `Color` 可以独立地进行扩展，而不会相互影响。如果要增加一个新的形状 `Triangle`，不需要改动任何 `Color` 的代码。反之亦然。
2. **极佳的扩展能力**：如果系统有 M 个形状和 N 种颜色，使用继承需要 `M*N` 个类，而使用桥接模式只需要 `M+N` 个类。
3. **符合开闭原则**：可以非常方便地对两个维度进行扩展。



### 组合模式 

**核心思想：** 将对象组合成**树形结构**以表示“部分-整体”的层次结构。组合模式使得客户端对**单个对象（叶子节点）**和**组合对象（容器节点）**的使用具有一致性。

**生活中的例子：** 电脑的文件系统。一个文件夹（容器）里面可以包含文件（叶子），也可以包含其他文件夹（容器）。对于用户来说，无论是文件还是文件夹，都可以执行“查看属性”、“重命名”、“删除”等操作。你无需区分操作的是单个文件还是整个文件夹。

#### 代码示例

模拟文件系统的例子。

**第一步：定义统一的组件接口**

```java
// 1. 统一的组件接口 (Component)
interface FileSystemItem {
    void display(); // 显示名称
    int getSize();    // 获取大小
}
```

**第二步：创建叶子节点**

```java
// 2. 叶子节点 (Leaf)
class File implements FileSystemItem {
    private String name;
    private int size;

    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public void display() {
        System.out.println("  - 文件: " + name + " (大小: " + size + "KB)");
    }

    @Override
    public int getSize() {
        return this.size;
    }
}
```

**第三步：创建容器节点**

```java
// 3. 容器节点 (Composite)
import java.util.ArrayList;
import java.util.List;

class Directory implements FileSystemItem {
    private String name;
    private List<FileSystemItem> items = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public void add(FileSystemItem item) {
        items.add(item);
    }

    @Override
    public void display() {
        System.out.println("文件夹: " + name);
        for (FileSystemItem item : items) {
            item.display(); // 递归显示
        }
    }

    @Override
    public int getSize() {
        int totalSize = 0;
        for (FileSystemItem item : items) {
            totalSize += item.getSize(); // 递归计算大小
        }
        return totalSize;
    }
}
```

**第四步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        Directory root = new Directory("根目录");
        Directory docs = new Directory("文档");
        Directory music = new Directory("音乐");

        File file1 = new File("简历.doc", 100);
        File file2 = new File("照片.jpg", 500);
        File file3 = new File("歌曲A.mp3", 4000);

        docs.add(file1);
        docs.add(file2);
        music.add(file3);

        root.add(docs);
        root.add(music);

        root.display();
        System.out.println("\n根目录总大小: " + root.getSize() + "KB");
    }
}
```

#### 优越性分析

1. **统一处理**：客户端代码可以统一地处理所有对象，无需区分它是叶子还是容器，这大大简化了客户端的逻辑。
2. **易于扩展**：可以很方便地增加新的叶子或容器类，只要它们实现了共同的接口即可。
3. **天然的递归结构**：非常适合用来表示具有层级关系的树形结构。



### 装饰器模式

**核心思想：** **动态地**给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。它是一种“即插即用”的增强方式。

**生活中的例子：** 给一杯咖啡加料。

- **核心对象：** 一杯原味咖啡。
- **装饰者：** 牛奶、糖、奶油... 你可以先点一杯咖啡，然后要求“加牛奶”（用牛奶装饰器包装一下），再要求“加糖”（再用糖装饰器包装一下）。每加一种料，就是用一个新的装饰器把已有的对象包起来，最终得到一个层层包裹的对象，价格和描述也随之累加。

#### 代码示例

以咖啡加料为例。

**第一步：定义核心组件接口**

```java
// 1. 核心组件接口 (Component)
interface Beverage {
    String getDescription();
    double cost();
}
```

**第二步：创建具体的核心组件**

```java
// 2. 具体组件 (ConcreteComponent)
class Coffee implements Beverage {
    @Override
    public String getDescription() {
        return "原味咖啡";
    }
    @Override
    public double cost() {
        return 10.0;
    }
}
```

**第三步：创建抽象装饰者和具体装饰者**

```java
// 3. 抽象装饰者 (Decorator)
abstract class CondimentDecorator implements Beverage {
    // 持有被装饰的 Beverage 对象
    protected Beverage beverage;

    public CondimentDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    // 将 getDescription() 委托给被包装的对象
    @Override
    public String getDescription() {
        return beverage.getDescription();
    }
}

// 4. 具体装饰者 (ConcreteDecorator)
class Milk extends CondimentDecorator {
    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", 加牛奶";
    }

    @Override
    public double cost() {
        return beverage.cost() + 3.0;
    }
}

class Sugar extends CondimentDecorator {
    public Sugar(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", 加糖";
    }

    @Override
    public double cost() {
        return beverage.cost() + 1.0;
    }
}
```

**第四步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        // 点一杯原味咖啡
        Beverage beverage = new Coffee();
        System.out.println(beverage.getDescription() + " ￥" + beverage.cost());

        // 给咖啡加牛奶
        beverage = new Milk(beverage);
        System.out.println(beverage.getDescription() + " ￥" + beverage.cost());

        // 再加糖
        beverage = new Sugar(beverage);
        System.out.println(beverage.getDescription() + " ￥" + beverage.cost());
    }
}
```

#### 优越性分析

1. **高度灵活**：可以在运行时动态地添加或删除功能，比静态的继承要灵活得多。
2. **避免类爆炸**：如果用继承，你需要创建 `加奶咖啡`、`加糖咖啡`、`加奶加糖咖啡` 等等大量的子类。装饰模式用少量的类就能实现任意组合。
3. **符合开闭原则**：可以在不修改现有核心对象代码的情况下，为其增加新功能。



### 外观模式

**核心思想：** 为子系统中的一组接口提供一个**统一的、简化的入口**。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**生活中的例子：** 启动家庭影院。要看一场电影，你可能需要：

1. 打开投影仪
2. 放下幕布
3. 打开DVD播放机
4. 打开音响
5. 调节音量
6. 将灯光调暗

这个过程非常繁琐。于是你买了一个“智能中控”（外观），它提供一个“观影模式”按钮。你一按，它就自动帮你完成以上所有步骤。这个“智能中控”就是外观，它简化了与复杂子系统（投影仪、幕布、音响等）的交互。

#### 代码示例

模拟家庭影院的例子。

**第一步：定义复杂的子系统**

```java
class Projector {
    public void on() { System.out.println("投影仪已开启"); }
    public void off() { System.out.println("投影仪已关闭"); }
}
class DvdPlayer {
    public void on() { System.out.println("DVD播放机已开启"); }
    public void play(String movie) { System.out.println("开始播放电影: " + movie); }
    public void off() { System.out.println("DVD播放机已关闭"); }
}
class Amplifier {
    public void on() { System.out.println("功放已开启"); }
    public void setVolume(int level) { System.out.println("音量设置为: " + level); }
    public void off() { System.out.println("功放已关闭"); }
}
```

**第二步：创建外观类**

```java
// 外观类 (Facade)
class HomeTheaterFacade {
    private Projector projector;
    private DvdPlayer dvdPlayer;
    private Amplifier amplifier;

    public HomeTheaterFacade(Projector projector, DvdPlayer dvdPlayer, Amplifier amplifier) {
        this.projector = projector;
        this.dvdPlayer = dvdPlayer;
        this.amplifier = amplifier;
    }

    // 简化操作：一键观影
    public void watchMovie(String movie) {
        System.out.println("--- 准备观影 ---");
        projector.on();
        amplifier.on();
        amplifier.setVolume(5);
        dvdPlayer.on();
        dvdPlayer.play(movie);
    }

    // 简化操作：一键结束
    public void endMovie() {
        System.out.println("\n--- 电影结束，关闭设备 ---");
        dvdPlayer.off();
        amplifier.off();
        projector.off();
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        // 创建子系统组件
        Projector projector = new Projector();
        DvdPlayer dvdPlayer = new DvdPlayer();
        Amplifier amplifier = new Amplifier();

        // 创建外观，并注入组件
        HomeTheaterFacade homeTheater = new HomeTheaterFacade(projector, dvdPlayer, amplifier);

        // 客户端只需要调用简单的方法
        homeTheater.watchMovie("盗梦空间");
        homeTheater.endMovie();
    }
}
```

#### 优越性分析

1. **简化接口**：客户端无需了解子系统的复杂内部结构，只需与外观类交互即可，大大降低了使用难度。
2. **降低耦合**：将客户端与子系统解耦。子系统的内部实现如何变化，只要外观接口不变，客户端代码就无需改动。
3. **提供入口**：为复杂的子系统提供了一个清晰的、单一的访问入口。



### 享元模式

**核心思想：** 运用**共享技术**来有效地支持大量细粒度的对象。它通过分离对象的**内部状态（Intrinsic）**和**外部状态（Extrinsic）**来减少创建对象的数量，从而节省内存。

- **内部状态**：可以被共享的、不随环境变化的部分。
- **外部状态**：不可以被共享的、随环境变化的部分。

**生活中的例子：** 下围棋。棋盘上有成百上千的棋子，但实际上我们只需要**两种**物理棋子：黑子和白子。

- **内部状态（享元）：** 棋子的颜色（黑或白）。这是可以共享的。我们不需要为棋盘上的每个位置都创建一个新的物理棋子。
- **外部状态：** 棋子在棋盘上的**位置**（例如，(3,4) 或 (10,12)）。这是不可共享的，由客户端（棋手）来维护。

每次落子时，你从棋盒（享元工厂）里拿一个黑子或白子（共享的享元对象），然后把它放在棋盘的某个位置上（提供外部状态）。

#### 代码示例

以绘制不同颜色的圆形为例，如果要在屏幕上画上万个，颜色只有几种。

**第一步：定义享元接口和具体享元**

```java
// 1. 享元接口
interface Shape {
    void draw(int x, int y); // 外部状态作为参数传入
}

// 2. 具体享元类
class Circle implements Shape {
    private String color; // 内部状态

    public Circle(String color) {
        this.color = color;
        System.out.println("创建了一个新的 " + color + " 圆形 (享元对象)");
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("在位置 (" + x + "," + y + ") 绘制一个 " + color + " 的圆形。");
    }
}
```

**第二步：创建享元工厂**

```java
import java.util.HashMap;

// 3. 享元工厂
class ShapeFactory {
    private static final HashMap<String, Shape> circleMap = new HashMap<>();

    public static Shape getCircle(String color) {
        Circle circle = (Circle) circleMap.get(color);

        if (circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
        }
        return circle;
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    private static final String colors[] = { "Red", "Green", "Blue", "White", "Black" };

    public static void main(String[] args) {
        System.out.println("--- 准备绘制20个圆形 ---");
        for (int i = 0; i < 20; ++i) {
            // 从工厂获取享元对象
            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
            // 传入外部状态
            circle.draw(getRandomX(), getRandomY());
        }
    }

    private static String getRandomColor() {
        return colors[(int) (Math.random() * colors.length)];
    }
    private static int getRandomX() { return (int) (Math.random() * 100); }
    private static int getRandomY() { return (int) (Math.random() * 100); }
}
```

对于那些拥有相同内在状态的对象，我们只创建一个共享的“享元对象”。当需要使用这个对象时，客户端从外部将变化的外在状态传递给它。这样一来，假设有1000个需要显示在屏幕上的“红色圆形”，我们不再需要创建1000个独立的圆形对象。我们只需要：

- **1个** 共享的“红色圆形”享元对象（内在状态：颜色=红，形状=圆）。
- **1000个** 坐标对象（外在状态），由客户端维护。

#### 优越性分析

1. **极大地减少内存消耗**：通过共享对象，避免了创建大量相似对象所带来的内存开销。在需要创建海量对象的场景下效果显著。
2. **提高性能**：减少了对象创建和垃圾回收的时间。



### 代理模式 

**核心思想：** 为其他对象提供一种**代理**以**控制**对这个对象的访问。代理对象和真实对象通常实现相同的接口。

**生活中的例子：** 海外代购。你想买一个国外的商品（真实对象），但由于距离、支付等问题无法直接购买。于是你找到一个代购（代理）。

- 代购帮你处理了所有复杂的中间环节（物流、关税、支付）。
- 代购可以做一些额外的操作，比如验货、加固包装。
- 你只和代购打交道，感觉就像直接在买东西一样。

#### 代码示例

以加载高分辨率图片为例，加载过程可能很耗时。

**第一步：定义共同的接口**

```Java
// 1. 共同接口 (Subject)
interface Image {
    void display();
}
```

**第二步：创建真实主题**

```Java
// 2. 真实主题 (RealSubject)
class RealImage implements Image {
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(fileName); // 构造时就加载，很耗时
    }

    private void loadFromDisk(String fileName) {
        System.out.println("正在从磁盘加载图片: " + fileName);
        // 模拟耗时操作
        try { Thread.sleep(2000); } catch (InterruptedException e) {}
    }

    @Override
    public void display() {
        System.out.println("显示图片: " + fileName);
    }
}
```

**第三步：创建代理**

```Java
// 3. 代理 (Proxy)
class ProxyImage implements Image {
    private RealImage realImage; // 持有真实对象的引用
    private String fileName;

    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        // 当真正需要显示时（懒加载），才创建和加载真实对象
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        // 代理可以增加额外的操作，如权限检查、日志记录等
        System.out.println("[Proxy] 准备显示...");
        realImage.display();
    }
}
```

**第四步：客户端使用**

```Java
public class Client {
    public static void main(String[] args) {
        // 创建代理对象，此时并未加载图片
        Image image = new ProxyImage("photo.jpg");

        // 第一次调用 display()，会触发真实对象的创建和加载
        System.out.println("--- 第一次显示 ---");
        image.display();

        System.out.println("\n--- 第二次显示 ---");
        // 第二次调用，直接显示，无需再次加载
        image.display();
    }
}
```

#### 优越性分析

1. **控制访问**：代理可以作为中间层，在访问真实对象前后进行预处理和后处理，如权限检查、日志记录等。
2. **增强功能**：可以在不修改真实对象的情况下，为其增加额外的功能（如懒加载）。
3. **解耦**：客户端与真实对象解耦，只与代理交互。



## 行为型设计模式

### 职责链模式

**核心思想：** 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

**生活中的例子：** 公司报销流程。

1. 你提交一笔 500 元的报销单。
2. 首先传给你的**小组长**（处理 1000 元以下的请求）。小组长审核通过，流程结束。
3. 如果你提交一笔 5000 元的报销单。
4. 小组长处理不了，他会把单子传给他的上级——**部门经理**（处理 10000 元以下的请求）。经理审核通过，流程结束。
5. 如果你提交 20000 元的报销单，经理也会传给他的上级——**总监**。 这个请求沿着“小组长 -> 经理 -> 总监”这条职责链传递，直到被处理。

#### 代码示例

模拟报销流程。

**第一步：定义处理器抽象类**

```Java
// 1. 抽象处理器 (Handler)
abstract class Approver {
    protected Approver nextApprover; // 指向链中的下一个处理器

    public void setNext(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    // 处理请求的抽象方法
    public abstract void processRequest(PurchaseRequest request);
}
```

**第二步：创建具体处理器**

```Java
// 报销单类
class PurchaseRequest {
    private double amount;
    public PurchaseRequest(double amount) { this.amount = amount; }
    public double getAmount() { return amount; }
}

// 2. 具体处理器
class TeamLead extends Approver {
    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() <= 1000) {
            System.out.println("小组长 审批通过了 " + request.getAmount() + " 元的报销。");
        } else if (nextApprover != null) {
            nextApprover.processRequest(request); // 传递给下一个
        }
    }
}

class Manager extends Approver {
    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() <= 10000) {
            System.out.println("部门经理 审批通过了 " + request.getAmount() + " 元的报销。");
        } else if (nextApprover != null) {
            nextApprover.processRequest(request);
        }
    }
}
```

**第三步：组装职责链并使用**

```Java
public class Client {
    public static void main(String[] args) {
        // 组装职责链
        Approver teamLead = new TeamLead();
        Approver manager = new Manager();
        // 还可以有 Director, CEO...

        teamLead.setNext(manager);

        // 发起请求
        teamLead.processRequest(new PurchaseRequest(800));
        teamLead.processRequest(new PurchaseRequest(5000));
        teamLead.processRequest(new PurchaseRequest(12000)); // 经理也处理不了，会断掉
    }
}
```

#### 优越性分析

1. **降低耦合**：请求的发送者完全不知道是哪个对象处理了请求，实现了发送者和接收者的解耦。
2. **灵活性高**：可以动态地组合职责链，在运行时改变链中的成员或调整它们的顺序。
3. **符合单一职责原则**：每个处理器只需要关注自己能处理的请求，职责清晰。



### 命令模式

**核心思想：** 将一个**请求**封装为一个**对象**，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

**生活中的例子：** 去餐厅点餐。

- **你 (Client):** 发出请求的人。
- **菜单上的菜品 (Command):** “宫保鸡丁”、“鱼香肉丝”等都是一个个具体的命令对象。
- **服务员 (Invoker):** 接收你的点单，但不负责做菜。他只负责把你的“命令”（订单）记录下来并传递给后厨。
- **厨师 (Receiver):** 真正执行命令的人。

服务员可以将多个订单（命令对象）排队送给后厨，后厨按顺序执行。整个过程中，你和服务员都不需要知道厨师是谁、具体怎么炒菜。

#### 代码示例

模拟一个简单的遥控器。

**第一步：定义命令接口和接收者**

```java
// 1. 命令接口 (Command)
interface Command {
    void execute();
    void undo(); // 支持撤销
}

// 2. 接收者 (Receiver)
class Light {
    public void on() { System.out.println("灯打开了"); }
    public void off() { System.out.println("灯关闭了"); }
}
```

**第二步：创建具体命令**

```java
// 3. 具体命令 (ConcreteCommand)
class LightOnCommand implements Command {
    private Light light; // 持有接收者的引用

    public LightOnCommand(Light light) { this.light = light; }

    @Override
    public void execute() { light.on(); }
    @Override
    public void undo() { light.off(); }
}

class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) { this.light = light; }

    @Override
    public void execute() { light.off(); }
    @Override
    public void undo() { light.on(); }
}
```

**第三步：创建调用者并使用**

```java
// 4. 调用者 (Invoker)
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        System.out.print("按下按钮 -> ");
        command.execute();
    }

    public void pressUndo() {
        System.out.print("按下撤销 -> ");
        command.undo();
    }
}

public class Client {
    public static void main(String[] args) {
        RemoteControl remote = new RemoteControl();
        Light livingRoomLight = new Light(); // 接收者

        // 创建命令对象
        Command lightOn = new LightOnCommand(livingRoomLight);
        Command lightOff = new LightOffCommand(livingRoomLight);

        // 设置并执行开灯命令
        remote.setCommand(lightOn);
        remote.pressButton();
        remote.pressUndo();

        // 设置并执行关灯命令
        remote.setCommand(lightOff);
        remote.pressButton();
        remote.pressUndo();
    }
}
```

#### 优越性分析

1. **解耦**：将调用操作的对象（`RemoteControl`）与知道如何实现该操作的对象（`Light`）解耦。
2. **一等公民**：命令被封装成对象，可以像其他对象一样被存储、传递和操作，这为实现队列、宏命令、日志、撤销/重做等功能提供了基础。
3. **易于扩展**：可以非常容易地增加新的命令，而无需修改现有调用者的代码。



### 解释器模式

核心思想：

给定一种语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。它通常用于构建特定领域语言（DSL）的解析器。

生活中的例子：

音乐乐谱。乐谱就是一种“语言”，它有自己的文法规则（音符、节拍、休止符等）。音乐家（解释器）看到乐谱后，就能按照这套文法规则，将其“解释”成实际的音乐。另一个例子是正则表达式，引擎（解释器）会解析你写的模式（语言），然后在文本中进行匹配。

#### 代码示例

实现一个简单的数学表达式解释器，如计算 `a + b - c`。

**第一步：定义抽象表达式和终结符表达式**

```java
import java.util.Map;

// 1. 抽象表达式接口 (AbstractExpression)
interface Expression {
    int interpret(Map<String, Integer> context); // context 存储变量和值
}

// 2. 终结符表达式 (TerminalExpression)
class VarExpression implements Expression {
    private String key;
    public VarExpression(String key) { this.key = key; }

    @Override
    public int interpret(Map<String, Integer> context) {
        return context.get(key);
    }
}
```

**第二步：定义非终结符表达式**

```java
// 3. 非终结符表达式 (Non-terminalExpression)
abstract class SymbolExpression implements Expression {
    protected Expression left;
    protected Expression right;
    public SymbolExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
}

class AddExpression extends SymbolExpression {
    public AddExpression(Expression left, Expression right) { super(left, right); }
    @Override
    public int interpret(Map<String, Integer> context) {
        return left.interpret(context) + right.interpret(context);
    }
}

class SubExpression extends SymbolExpression {
    public SubExpression(Expression left, Expression right) { super(left, right); }
    @Override
    public int interpret(Map<String, Integer> context) {
        return left.interpret(context) - right.interpret(context);
    }
}
```

**第三步：客户端使用（通常会有一个解析器来构建表达式树）**

```java
import java.util.HashMap;

public class Client {
    public static void main(String[] args) {
        // 假设表达式是 a + b - c
        // 实际应用中，这个表达式树是由一个专门的解析器根据字符串生成的
        Expression a = new VarExpression("a");
        Expression b = new VarExpression("b");
        Expression c = new VarExpression("c");
        Expression add = new AddExpression(a, b);
        Expression finalExpression = new SubExpression(add, c);

        // 设置变量的值
        Map<String, Integer> context = new HashMap<>();
        context.put("a", 10);
        context.put("b", 20);
        context.put("c", 5);

        // 解释并计算
        int result = finalExpression.interpret(context);
        System.out.println("表达式 a + b - c 的结果是: " + result); // 10 + 20 - 5 = 25
    }
}
```

#### 优越性分析

1. **易于扩展语法**：当需要增加新的语法规则时，只需增加新的非终结符表达式类即可，符合开闭原则。
2. **文法表示清晰**：使用类来表示文法规则，结构清晰，易于理解和实现。

**注意**：解释器模式适用于文法规则相对简单的场景。对于复杂的文法，维护大量的表达式类会导致系统非常复杂，此时更适合使用专业的解析器生成工具（如 ANTLR）。



### 迭代器模式

核心思想：

提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。这是Java集合框架的核心模式之一。

生活中的例子：

电视遥控器的“频道+”和“频道-”按钮。你可以用这两个按钮遍历所有频道，但你完全不需要知道电视台是如何在电视机内部存储频道列表的（是用数组、链表还是其他数据结构）。遥控器（迭代器）为你提供了一个统一的遍历接口。

#### 代码示例

手动实现一个简单的迭代器。

**第一步：定义迭代器和容器接口**

```java
// 1. 迭代器接口 (Iterator)
interface Iterator<E> {
    boolean hasNext();
    E next();
}

// 2. 容器接口 (Aggregate)
interface Container<E> {
    Iterator<E> getIterator();
}
```

**第二步：创建具体容器和具体迭代器**

```java
// 3. 具体容器
class NameRepository implements Container<String> {
    public String names[] = {"Robert", "John", "Julie", "Lora"};

    @Override
    public Iterator<String> getIterator() {
        return new NameIterator();
    }

    // 4. 具体迭代器（通常作为内部类实现，以便访问外部类的成员）
    private class NameIterator implements Iterator<String> {
        int index;

        @Override
        public boolean hasNext() {
            return index < names.length;
        }

        @Override
        public String next() {
            if (this.hasNext()) {
                return names[index++];
            }
            return null;
        }
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        NameRepository namesRepository = new NameRepository();

        // 客户端通过统一的迭代器接口进行遍历，不关心内部是数组还是其他结构
        for (Iterator<String> iter = namesRepository.getIterator(); iter.hasNext(); ) {
            String name = iter.next();
            System.out.println("Name : " + name);
        }
    }
}
```

#### 优越性分析

1. **封装内部结构**：客户端无需知道集合的内部数据结构，降低了耦合。
2. **统一遍历接口**：为不同的数据结构（数组、列表、树等）提供了统一的遍历方式。
3. **支持多种遍历**：一个聚合对象可以同时拥有多个独立的迭代器在遍历。



### 中介者模式

核心思想：

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它将复杂的“网状”通信结构，变成了简单的“星状”结构。

生活中的例子：

机场的控制塔。飞机（同事类）之间不会直接通信来协调起降，否则会天下大乱。所有飞机都只和控制塔（中介者）通信，由控制塔来统一协调所有飞机的航线和起降顺序。

#### 代码示例

模拟一个聊天室。

**第一步：定义中介者和同事类**

```java
// 1. 中介者接口
interface ChatMediator {
    void sendMessage(String msg, User user);
    void addUser(User user);
}

// 2. 抽象同事类
abstract class User {
    protected ChatMediator mediator;
    protected String name;
    public User(ChatMediator med, String name) {
        this.mediator = med;
        this.name = name;
    }
    public abstract void send(String msg);
    public abstract void receive(String msg);
}
```

**第二步：创建具体中介者和具体同事类**

```java
import java.util.ArrayList;
import java.util.List;
// 3. 具体中介者
class ChatMediatorImpl implements ChatMediator {
    private List<User> users;
    public ChatMediatorImpl() { this.users = new ArrayList<>(); }

    @Override
    public void addUser(User user) { this.users.add(user); }

    @Override
    public void sendMessage(String msg, User user) {
        for (User u : this.users) {
            // 不把消息发回给发送者自己
            if (u != user) {
                u.receive(msg);
            }
        }
    }
}

// 4. 具体同事类
class UserImpl extends User {
    public UserImpl(ChatMediator med, String name) { super(med, name); }
    @Override
    public void send(String msg) {
        System.out.println(this.name + " 发送消息: " + msg);
        mediator.sendMessage(msg, this);
    }
    @Override
    public void receive(String msg) {
        System.out.println(this.name + " 接收到消息: " + msg);
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        ChatMediator mediator = new ChatMediatorImpl();
        User user1 = new UserImpl(mediator, "张三");
        User user2 = new UserImpl(mediator, "李四");
        User user3 = new UserImpl(mediator, "王五");

        mediator.addUser(user1);
        mediator.addUser(user2);
        mediator.addUser(user3);

        user1.send("大家好！");
    }
}
```

#### 优越性分析

1. **降低耦合度**：将多对多的复杂关系转变为一对多的简单关系，各个同事类之间不再直接依赖。
2. **集中控制**：将复杂的交互逻辑集中到中介者中，使得交互变得清晰、易于管理和维护。
3. **符合单一职责**：同事类只关心自身业务，交互的逻辑由中介者负责。



### 备忘录模式

核心思想：

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。它常用于实现“撤销”（Undo）功能。

生活中的例子：

游戏的存档功能。

- **游戏角色 (Originator/发起人):** 拥有状态（HP, MP, 装备等）。
- **存档文件 (Memento/备忘录):** 角色状态的一个快照。这个文件对玩家来说是“不透明”的，你不能直接编辑它。
- **你/游戏系统 (Caretaker/负责人):** 负责保管存档文件，但不知道其内部结构。

当你需要时，可以让游戏角色读取存档文件，恢复到之前的状态。

#### 代码示例

模拟一个文本编辑器的撤销功能。

```java
// 1. 备忘录 (Memento)
class Memento {
    private final String state; // 使用 final 保证状态不可变
    public Memento(String state) { this.state = state; }
    public String getState() { return state; }
}

// 2. 发起人 (Originator)
class Editor {
    private String content;

    public void setContent(String content) { this.content = content; }
    public String getContent() { return content; }

    public Memento createMemento() {
        return new Memento(content);
    }
    public void restore(Memento memento) {
        this.content = memento.getState();
    }
}

// 3. 负责人 (Caretaker)
import java.util.Stack;
class History {
    private Stack<Memento> mementos = new Stack<>();
    public void push(Memento memento) { mementos.push(memento); }
    public Memento pop() { return mementos.pop(); }
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        Editor editor = new Editor();
        History history = new History();

        editor.setContent("版本 A");
        history.push(editor.createMemento());

        editor.setContent("版本 B");
        history.push(editor.createMemento());

        editor.setContent("版本 C");
        System.out.println("当前内容: " + editor.getContent());

        // 第一次撤销
        editor.restore(history.pop());
        System.out.println("撤销后内容: " + editor.getContent());

        // 第二次撤销
        editor.restore(history.pop());
        System.out.println("再次撤销后内容: " + editor.getContent());
    }
}
```

#### 优越性分析

1. **保护封装性**：负责人（`History`）只持有备忘录对象，但不能访问其内部状态，保证了发起人（`Editor`）内部数据的封装。
2. **简化发起人**：发起人不需要管理自己的历史状态，将状态的存储和恢复逻辑分离出去，使自身更纯粹。
3. **提供状态恢复机制**：为实现撤销、重做、事务回滚等功能提供了清晰的实现方案。



### 观察者模式

核心思想：

定义对象间的一种一对多的依赖关系，当一个对象（主题/被观察者）的状态发生改变时，所有依赖于它的对象（观察者）都得到通知并被自动更新。这是发布-订阅（Pub-Sub）模型的一种实现。

生活中的例子：

微信公众号。

- **公众号 (Subject/主题):** 被观察者。

- 你和其他订阅者 (Observer/观察者): 订阅了公众号。

  当公众号发布一篇新文章（状态改变）时，它会通知所有订阅者，然后你的微信上就会出现红点提示。你随时可以“关注”或“取关”，动态地建立或解除依赖关系。

#### 代码示例

模拟新闻发布者和订阅者。

**第一步：定义主题和观察者接口**

```java
// 1. 观察者接口
interface Observer {
    void update(String message);
}

// 2. 主题接口
interface Subject {
    void register(Observer o);
    void unregister(Observer o);
    void notifyObservers();
}
```

**第二步：创建具体主题和具体观察者**

```java
import java.util.ArrayList;
import java.util.List;
// 3. 具体主题
class NewsPublisher implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String latestNews;

    @Override
    public void register(Observer o) { observers.add(o); }
    @Override
    public void unregister(Observer o) { observers.remove(o); }
    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(latestNews);
        }
    }

    public void setLatestNews(String news) {
        this.latestNews = news;
        System.out.println("发布新消息: " + news);
        notifyObservers();
    }
}

// 4. 具体观察者
class EmailSubscriber implements Observer {
    private String name;
    public EmailSubscriber(String name) { this.name = name; }
    @Override
    public void update(String message) {
        System.out.println(name + " (通过邮件) 收到推送: " + message);
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        NewsPublisher publisher = new NewsPublisher();

        Observer sub1 = new EmailSubscriber("张三");
        Observer sub2 = new EmailSubscriber("李四");

        publisher.register(sub1);
        publisher.register(sub2);

        publisher.setLatestNews("今天天气晴朗！");

        System.out.println("\n--- 李四取消了订阅 ---");
        publisher.unregister(sub2);

        publisher.setLatestNews("明天可能下雨。");
    }
}
```

#### 优越性分析

1. **松散耦合**：主题和观察者之间是松散耦合的。主题只知道它有一系列观察者，但不知道它们是谁、是干什么的。
2. **支持广播**：一个消息可以被广播给任意数量的观察者。
3. **动态关系**：可以在运行时动态地增加或删除观察者。



### 状态模式

核心思想：

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。

生活中的例子：

自动售货机。

- 状态1：没投币 (NoCoinState) -> 此时你按购买按钮，它会提示“请投币”。

- 状态2：已投币 (HasCoinState) -> 此时你按购买按钮，它会出货，并回到“没投币”状态。

- 状态3：已售罄 (SoldOutState) -> 此时你投币，它会退币并提示“已售罄”。

  自动售货机（上下文）的行为完全取决于它当前所处的状态。

#### 代码示例

模拟一个文档的状态流转（草稿 -> 审核中 -> 已发布）。

**第一步：定义状态接口和上下文**

```java
// 1. 上下文 (Context)
class Document {
    private State state;
    public Document() { this.state = new DraftState(); } // 初始状态为草稿
    public void setState(State state) {
        this.state = state;
        System.out.println("文档状态变为: " + state.getClass().getSimpleName());
    }
    public void publish() { state.handlePublish(this); }
}

// 2. 状态接口 (State)
interface State {
    void handlePublish(Document doc);
}
```

**第二步：创建具体状态类**

```java
// 3. 具体状态
class DraftState implements State {
    @Override
    public void handlePublish(Document doc) {
        System.out.println("草稿已提交审核。");
        doc.setState(new ModerationState());
    }
}

class ModerationState implements State {
    @Override
    public void handlePublish(Document doc) {
        System.out.println("审核通过，文档已发布。");
        doc.setState(new PublishedState());
    }
}

class PublishedState implements State {
    @Override
    public void handlePublish(Document doc) {
        System.out.println("错误：文档已发布，无法重复操作。");
    }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        Document doc = new Document();

        doc.publish(); // 从草稿 -> 审核中
        doc.publish(); // 从审核中 -> 已发布
        doc.publish(); // 已发布，无法操作
    }
}
```

#### 优越性分析

1. **消除庞大的条件语句**：将每个状态的行为封装在各自的类中，避免了在一个类里写满 `if/else` 或 `switch`。
2. **职责清晰**：与特定状态相关的代码都放在一个类里，符合单一职责原则。
3. **状态转换明确**：状态的转换逻辑变得非常清晰，易于理解和维护。



### 策略模式

核心思想：

定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

生活中的例子：

地图App的路线规划。

- **你 (Context):** 使用地图App的人。

- 出行方式 (Strategy): 开车、公交、步行、骑行。

  你选择了“开车”（策略A），App就用“最短行车时间”算法为你规划路线。你选择了“步行”（策略B），App就用“抄近道”算法为你规划。你可以随时切换策略，而App本身（上下文）的核心功能不变。

#### 代码示例

模拟一个商场根据不同促销活动计算价格。

**第一步：定义策略接口和上下文**

```java
// 1. 策略接口
interface PromotionStrategy {
    double doPromotion(double price);
}

// 2. 上下文
class ShoppingCart {
    private PromotionStrategy strategy;
    public void setStrategy(PromotionStrategy strategy) { this.strategy = strategy; }
    public double checkout(double price) {
        return strategy.doPromotion(price);
    }
}
```

**第二步：创建具体策略**

```java
// 3. 具体策略
class NoDiscountStrategy implements PromotionStrategy {
    @Override
    public double doPromotion(double price) { return price; }
}
class TenPercentOffStrategy implements PromotionStrategy {
    @Override
    public double doPromotion(double price) { return price * 0.9; }
}
class FullReductionStrategy implements PromotionStrategy {
    @Override
    public double doPromotion(double price) { return price >= 200 ? price - 20 : price; }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        double originalPrice = 250.0;

        // 场景1：无活动
        cart.setStrategy(new NoDiscountStrategy());
        System.out.println("无活动，价格: " + cart.checkout(originalPrice));

        // 场景2：9折
        cart.setStrategy(new TenPercentOffStrategy());
        System.out.println("9折活动，价格: " + cart.checkout(originalPrice));

        // 场景3：满200减20
        cart.setStrategy(new FullReductionStrategy());
        System.out.println("满200减20，价格: " + cart.checkout(originalPrice));
    }
}
```

#### 优越性分析

1. **算法自由切换**：可以在运行时根据需要灵活地切换算法。
2. **避免多重条件判断**：如果不用策略模式，你可能需要在 `checkout` 方法里写大量的 `if/else` 来判断当前是什么活动。
3. **符合开闭原则**：增加一个新的促销活动（新策略），无需修改 `ShoppingCart` 的代码，只需增加一个新的策略类。



### 模板方法模式

核心思想：

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

生活中的例子：

制作饮料。无论是泡茶还是冲咖啡，基本流程（模板）是固定的：

1. 把水烧开。（固定步骤）

2. **冲泡**。（可变步骤：泡茶包 vs 冲咖啡粉）

3. 把饮料倒进杯子。（固定步骤）

4. 加调料。（可变步骤：加柠檬 vs 加奶和糖）

   这个固定的流程就是模板方法，而“冲泡”和“加调料”是留给子类（泡茶、冲咖啡）去具体实现的步骤。

#### 代码示例

模拟制作饮料。

**第一步：创建抽象模板类**

```java
// 1. 抽象模板类
abstract class BeverageMaker {
    // 模板方法，用 final 修饰，防止子类覆盖
    public final void makeBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) { // 这是一个“钩子”
            addCondiments();
        }
    }

    // 具体方法
    private void boilWater() { System.out.println("1. 烧开水"); }
    private void pourInCup() { System.out.println("3. 倒进杯子"); }

    // 抽象方法，由子类实现
    protected abstract void brew();
    protected abstract void addCondiments();

    // 钩子方法 (Hook)，子类可以选择性地覆盖
    protected boolean customerWantsCondiments() {
        return true;
    }
}
```

**第二步：创建具体子类**

```java
// 2. 具体子类
class CoffeeMaker extends BeverageMaker {
    @Override
    protected void brew() { System.out.println("2. 用沸水冲泡咖啡"); }
    @Override
    protected void addCondiments() { System.out.println("4. 加糖和牛奶"); }
}

class TeaMaker extends BeverageMaker {
    @Override
    protected void brew() { System.out.println("2. 用沸水浸泡茶叶"); }
    @Override
    protected void addCondiments() { System.out.println("4. 加柠檬"); }
}
```

**第三步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        System.out.println("--- 制作咖啡 ---");
        BeverageMaker coffee = new CoffeeMaker();
        coffee.makeBeverage();

        System.out.println("\n--- 制作茶 ---");
        BeverageMaker tea = new TeaMaker();
        tea.makeBeverage();
    }
}
```

钩子方法

#### 优越性分析

1. **代码复用**：将公共代码（算法骨架）放在父类中，提高代码复用性。
2. **封装不变部分，扩展可变部分**：将算法的固定结构封装起来，通过子类来扩展变化的部分，非常清晰。
3. **行为控制**：通过模板方法，父类可以控制子类的行为，规定了子类必须遵循的算法流程。



### 访问者模式

核心思想：

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。这是一种将数据结构和数据操作分离的技术。

生活中的例子：

一个动物园里有狮子、猴子、海豚等动物（稳定的数据结构）。

- **操作1：喂食员 (Visitor 1)** 来到动物园，他会给狮子喂肉，给猴子喂香蕉。

- 操作2：兽医 (Visitor 2) 来到动物园，他会给狮子检查牙齿，给猴子检查皮毛。

  动物本身没有变，但我们通过不同的访问者（喂食员、兽医），对它们执行了完全不同的操作。如果需要一个新的操作（比如“清洁工”），只需增加一个新的访问者即可，无需修改任何动物类。

#### 代码示例

模拟电脑的不同部件接受不同访问者的操作。

**第一步：定义访问者和元素接口**

```java
// 先声明，后面会用到
interface ComputerPartVisitor {
    void visit(Keyboard keyboard);
    void visit(Monitor monitor);
}

// 1. 元素接口
interface ComputerPart {
    void accept(ComputerPartVisitor visitor);
}
```

**第二步：创建具体元素**

```java
// 2. 具体元素
class Keyboard implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor visitor) {
        visitor.visit(this); // 双分派：第一次分派到 accept，第二次分派到 visit
    }
}
class Monitor implements ComputerPart {
    @Override
    public void accept(ComputerPartVisitor visitor) {
        visitor.visit(this);
    }
}
// 组合元素
class Computer implements ComputerPart {
    ComputerPart[] parts;
    public Computer() { parts = new ComputerPart[]{new Keyboard(), new Monitor()}; }
    @Override
    public void accept(ComputerPartVisitor visitor) {
        for (ComputerPart part : parts) {
            part.accept(visitor);
        }
        visitor.visit(this); // 假设Computer本身也需要被访问
    }
}
```

**第三步：创建具体访问者**

```java
// 3. 具体访问者
class ComputerPartDisplayVisitor implements ComputerPartVisitor {
    @Override
    public void visit(Keyboard keyboard) { System.out.println("显示键盘。"); }
    @Override
    public void visit(Monitor monitor) { System.out.println("显示显示器。"); }
    // 在这里添加对Computer的访问实现
    public void visit(Computer computer) { System.out.println("显示电脑主机。"); }
}

class ComputerPartCheckVisitor implements ComputerPartVisitor {
    @Override
    public void visit(Keyboard keyboard) { System.out.println("检查键盘连接。"); }
    @Override
    public void visit(Monitor monitor) { System.out.println("检查显示器像素。"); }
    public void visit(Computer computer) { System.out.println("检查电脑电源。"); }
}
```

**第四步：客户端使用**

```java
public class Client {
    public static void main(String[] args) {
        ComputerPart computer = new Computer();

        System.out.println("--- 使用 Display Visitor ---");
        computer.accept(new ComputerPartDisplayVisitor());

        System.out.println("\n--- 使用 Check Visitor ---");
        computer.accept(new ComputerPartCheckVisitor());
    }
}
```

#### 优越性分析

1. **符合开闭原则**：可以在不修改现有对象结构的情况下，轻松添加新的操作（新的访问者）。
2. **集中相关操作**：将对一个对象结构的一系列相关操作集中到一个访问者类中。
3. **分离数据和操作**：将数据结构（元素）和作用于其上的操作（访问者）解耦。

**缺点**：增加新的元素类很困难。因为每增加一个新元素，就必须在所有访问者接口和实现中增加对应的 `visit` 方法，违反了开闭原则。因此，它适用于**数据结构稳定，但操作易于变化**的场景。



## 三大类设计模式的区别

它们的根本区别在于**关注点**不同：

- **创建型模式关注“如何创建对象？”**
  - **核心目标**：实现创建逻辑的解耦。让你不必关心对象是如何被创建、组合和表示的，只需通过统一的接口来获取所需的对象。
  - **好比**：你去快餐店点餐，你不用关心汉堡是怎么做出来的（是烤还是炸，放几片生菜），你只需要告诉收银员“我要一个XX汉堡”（调用工厂），然后就能拿到成品。
- **结构型模式关注“如何组织对象？”**
  - **核心目标**：通过组合类和对象来形成更大的、功能更强的结构，同时保持结构的灵活性和效率。
  - **好比**：组装一台电脑。你需要把CPU、主板、内存条（不同的对象）通过标准的接口（如PCIe, SATA）组合在一起（适配器、桥接、组合模式），最终形成一台可以工作的电脑（一个更大的结构）。
- **行为型模式关注“对象如何交互和协作？”**
  - **核心目标**：在不同的对象之间有效地分配职责和封装行为，降低对象间的耦合度。
  - **好比**：公司里不同部门的协作流程。一个请求（例如报销申请）可能需要经过员工提交->主管审批->财务打款等一系列流程（责任链模式），每个角色（对象）只关心自己的任务，并与流程中的下一个角色进行通信。
