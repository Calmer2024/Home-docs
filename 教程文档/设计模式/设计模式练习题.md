# 设计模式练习题

CloudSmartMeeting：云端会议

SmartHomeSynthesize：智能家居

Multi-platformMultimediaPlayer：多平台媒体播放器

SmartHomeApp：智能家居



# 设计模式综合大作业：云端智能会议系统

## 一、背景与目标

本案例要求学生设计一个云端智能会议系统，支持会议的构建、管理、通知与执行全过程。系统应具备高扩展性与清晰模块边界，通过综合使用三类设计模式（创建型、结构型、行为型）进行架构设计与实现。

## 二、功能需求

1. 用户可以发起会议，设置议程、时间、参会人员等
2. 支持三种平台（Web、Desktop、Mobile）的平台适配
3. 自动发送参会通知，并支持撤销、重做等操作
4. 自动生成会议记录，可叠加摘要、关键词、语义分析插件
5. 允许切换不同的资源调度策略

## 三、任务分解与模式应用

### 任务1：抽象工厂（Abstract Factory）

\- 创建接口 ComponentFactory，定义 createNotifier(), createNetManager(), createUI() 等

\- 实现 WebComponentFactory、DesktopComponentFactory、MobileComponentFactory

\- 不同平台返回不同组件（如 WebNotifier、MobileUI）

### 任务2：建造者模式（Builder）

\- 创建 MeetingBuilder 接口和 Director

\- 包括设置议程 setAgenda(String)、设置时间 setTime(String)、设置主持人 setHost(User) 等方法

\- 返回完整 Meeting 对象

### 任务3：桥接模式（Bridge）

\- MeetingController 抽象类中持有 PlatformAPI 接口对象

\- PlatformAPI 定义 videoOn()、audioOff() 等方法

\- 子类 WindowsPlatformAPI、WebPlatformAPI 等

### 任务4：装饰器模式（Decorator）

\- 创建 MeetingRecord 接口

\- ConcreteMeetingRecord 实现基础记录

\- 其他装饰器类如 SummaryDecorator、KeywordDecorator 实现增强功能

### 任务5：外观模式（Facade）

\- 提供 MeetingSystem 类，方法有：createMeeting()、startMeeting()、endMeeting()

\- 封装了会议构建、组件注册、通知、控制等调用

### 任务6：观察者模式（Observer）

\- MeetingStatusManager 实现 Subject

\- 各子模块实现 Observer，如 UIObserver、LoggerObserver

### 任务7：策略模式（Strategy）

\- 定义接口 SchedulingStrategy，包含 schedule() 方法

\- 实现类有 EnergySavingStrategy、PerformanceFirstStrategy

### 任务8：命令模式（Command）

\- 接口 Command 包含 execute()、undo() 方法

\- 具体命令类有 CreateMeetingCommand、CancelMeetingCommand

\- 使用 Invoker 管理指令调用与撤销

## 四、类设计参考

你应至少实现以下核心类或接口：

\- MeetingBuilder / Meeting / Director

\- ComponentFactory / WebComponentFactory / WebNotifier 等

\- MeetingRecord + 若干装饰类

\- MeetingSystem (Facade)

\- Observer / Subject 接口实现

\- SchedulingStrategy 接口实现

\- Command 接口及其实现类

## 五、运行样例场景

用户：点击“发起会议”
-> 系统使用建造者构建会议对象
-> 选择 Web 平台组件工厂，创建 UI/通知器
-> 调用 MeetingSystem.createMeeting() 触发一系列操作
-> 注册观察者：前端 UI、日志模块、远程监听器
-> 应用 PerformanceFirstStrategy 进行资源调度
-> 添加关键词分析记录器装饰器
-> 用户点击“撤销会议”，命令执行 undo()，回滚创建动作



# 行为型设计模式大作业：智能家居控制系统

## 一、项目背景

你需要设计并实现一个智能家居控制系统。用户可以通过语音、App 或定时指令控制家庭中的各种设备，如灯光、窗帘、空调、安全系统等。系统应支持命令的记录与撤销、指令组合、设备状态管理、事件触发等功能。为提升系统的灵活性与可扩展性，你需要综合运用多种行为型设计模式进行系统设计与实现。

## 二、设计目标

本案例旨在帮助你掌握以下行为型设计模式的协同应用能力：

1. 命令模式
2. 状态模式
3. 观察者模式
4. 模板方法模式
5. 责任链模式
6. 策略模式

## 三、开发任务分解

### 任务1：实现命令模式

目标：将用户操作（开灯、关空调等）封装为命令对象，实现解耦。

\- 定义命令接口 Command，包含 execute() 和 undo() 方法

\- 实现具体命令类 LightOnCommand、CurtainOpenCommand 等

\- 定义控制器类 RemoteControl，支持命令设置与执行

### 任务2：实现状态模式

目标：支持设备的状态切换（如空调开/关、窗帘打开/关闭）

\- 定义状态接口 DeviceState，包含方法 handle()

\- 实现状态类 OnState、OffState

\- 在设备类中持有当前状态并委托状态执行操作

### 任务3：实现观察者模式

目标：当某个传感器状态发生变化时通知所有订阅者（如温度传感器变化通知空调）

\- 定义 Subject 接口及其实现 Sensor

\- 定义 Observer 接口及其实现类如 AirConditioner

\- 当温度变化时，Sensor 调用 notifyObservers 通知设备自动响应

### 任务4：实现模板方法模式

目标：定义设备执行流程的模板（如空调开机顺序：检测 -> 通电 -> 开启风扇）

\- 定义抽象类 SmartDevice，包含模板方法 startup()	

\- 子类如 AirConditioner、WashingMachine 实现具体步骤

### 任务5：实现责任链模式

目标：处理语音指令链，如“打开空调并拉窗帘”

\- 定义 Handler 接口

\- 创建 VoiceHandler、CurtainHandler、ACHandler 等链式结构

### 任务6：实现策略模式

目标：支持用户自定义执行策略（如节能模式、快速响应模式）

\- 定义策略接口 DeviceStrategy

\- 实现类 EnergySavingStrategy、FastResponseStrategy

\- 在设备中可动态切换策略执行行为

## 四、运行示例

用户：语音输入“打开空调”
 -> VoiceHandler 处理并交由 ACHandler
 -> 空调执行 FastResponseStrategy：立即开机
 -> 状态变更为：开启状态
传感器：检测到温度下降 -> 通知空调
 -> 空调自动降档运行（策略变更）
用户撤销操作 -> 空调执行 undo -> 状态变为关闭



# 结构型设计模式大作业：多平台多媒体播放器系统

## 一、项目背景

为了构建一个可扩展、易维护的多平台多媒体播放器系统，我们需要支持播放不同格式的媒体文件（如 MP3、MP4、AVI），并支持跨平台播放（如 Windows、Linux）。此外，为了提升用户体验，该播放器还应支持播放过程中的附加功能（如字幕、倍速、音效增强），同时具备播放列表的组织能力和访问权限控制。为简化客户端调用过程，应对系统暴露一个统一的操作接口。

## 二、任务目标

本练习题旨在训练你将多种结构型设计模式融合运用，构建复杂系统的能力。你需要使用以下六种结构型设计模式：桥接模式、装饰器模式、组合模式、适配器模式、代理模式和外观模式。

## 三、开发任务分解

### 任务1：实现桥接模式结构

目标：解耦媒体类型（MP3、MP4）与播放平台（Windows、Linux）。

要求：

\- 定义接口 Platform，包含方法 decode(String filename)。

\- 创建类 WindowsPlatform 和 LinuxPlatform 实现 Platform 接口。

\- 定义抽象媒体类（可选）或直接定义类 MP3 与 MP4，实现接口 Media。

\- 媒体类持有 Platform 引用，通过 platform.decode(...) 播放文件。

实现建议：桥接模式重点在于媒体种类和平台种类之间的解耦。

### 任务2：实现装饰器模式结构

目标：为媒体播放过程动态叠加功能，如字幕、倍速播放、音效增强等。

要求：

\- 创建抽象类 MediaDecorator，实现 Media 接口并持有 Media 实例。

\- 创建具体装饰类 SubtitleDecorator、SpeedDecorator、EffectDecorator。

\- 每个装饰器调用原始 media.play()，再叠加附加操作。

实现建议：可将多个装饰器组合使用，形成链式调用结构。

### 任务3：实现组合模式结构

目标：使用播放列表统一管理媒体项或嵌套播放列表，实现递归播放。

要求：

\- 定义类 Playlist，实现 Media 接口。

\- 定义 List<Media> 成员变量，支持添加媒体或子播放列表。

\- 在 play() 方法中，遍历 items 调用每个媒体项的 play()。

实现建议：Playlist 和 MP3/MP4 都实现 Media 接口，形成树形结构。

### 任务4：实现适配器模式结构

目标：将老旧 AVI 媒体格式转换为系统可播放格式（通过适配 MP4）。

要求：

\- 创建类 AviAdapter，实现 Media 接口。

\- 在内部持有 MP4 实例，将 AVI 文件名包装成 MP4 并播放。

实现建议：适配器模式用于“接口转换”，让 AVI 行为看起来像 Media。

### 任务5：实现代理模式结构

目标：在播放前进行权限验证，播放后记录日志。

要求：

\- 创建类 MediaProxy，实现 Media 接口。

\- MediaProxy 构造函数中接收真实 Media 对象和用户身份。

\- 在 play() 中先判断权限，再调用真实对象的 play()，并打印日志。

实现建议：可设置用户 admin 具有播放权限，非 admin 提示权限不足。

### 任务6：实现外观模式结构

目标：简化客户端播放流程，提供统一播放入口。

要求：

\- 创建类 MediaPlayerFacade，包含方法 playMedia(Media media)。

\- 在客户端只使用 facade 对象播放任意媒体或播放列表。

实现建议：将播放、装饰、代理等过程对客户端隐藏，降低复杂度。

## 四、参考输出

媒体播放开始：
播放媒体：song1.mp3（Windows平台）
-> 字幕开启
-> 1.5 倍速
播放媒体：video1.mp4（Linux平台）
-> 音效增强
播放媒体：video2.avi（通过适配器转换）
播放子播放列表：
播放媒体：song2.mp3
权限验证成功
日志记录：song2.mp3 已播放



# 创建型-智能家居设备控制平台的设备创建模块

## **背景场景：**

在一个智能家居平台中，用户可以通过手机 App 添加多种设备，比如：

- 智能灯（SmartLight）
- 智能空调（SmartAirConditioner）
- 智能音箱（SmartSpeaker）

不同设备厂商（如小米、华为、飞利浦）提供各自设备的实现和初始化方式。平台必须根据用户选择的“设备类型”和“厂商”创建对应的设备对象，并确保：

- 创建过程灵活扩展，不修改已有代码（**工厂方法/抽象工厂**）
- 有些核心类只能有一个实例（**单例**）
- 某些设备初始化非常复杂，如音箱可能包含语音识别模块、Wi-Fi 模块、音效设置等（**建造者模式**）
- 某些设备创建后要批量复制相似对象，如多个房间部署相同灯具配置（**原型模式**）



## **涉及的创建型模式**

| **模式名** | **在此场景中的用途**                     |
| ---------- | ---------------------------------------- |
| 单例模式   | 控制平台的“设备中心管理器”只能有一个实例 |
| 工厂方法   | 为每种设备类型定义一个工厂               |
| 抽象工厂   | 根据厂商批量创建不同类型的设备           |
| 建造者模式 | 构建复杂的设备（如智能音箱）             |
| 原型模式   | 快速复制已有设备配置用于部署             |



## **案例要求与功能说明**

**用户通过界面选择设备类型和厂商**

例如：

请选择设备类型：[Light, AirConditioner, Speaker]

请选择设备厂商：[Xiaomi, Huawei, Philips]

系统将创建对应厂商的设备对象，例如：

- XiaomiLight
- HuaweiAirConditioner
- PhilipsSpeaker



**不同厂商的设备实现细节不同**

例如：

- XiaomiLight 需要初始化米家协议
- HuaweiSpeaker 默认语音助手是小艺



**部署多个房间的同款设备时，使用原型模式**

SmartLight template = new XiaomiLight();

SmartLight light2 = template.clone();

SmartLight light3 = template.clone();



**智能音箱设备初始化复杂：通过建造者创建**

SpeakerBuilder builder = new HuaweiSpeakerBuilder();

Director director = new Director(builder);

SmartSpeaker speaker = director.construct();



**系统中的 DeviceManager 为单例，集中管理设备注册与列表**

DeviceManager.getInstance().register(device);



**编程练习目标**

1. 使用工厂方法模式为每种设备类型创建工厂（如 LightFactory）
2. 使用抽象工厂创建“设备族”（如    XiaomiDeviceFactory → 生产小米灯、小米空调等）
3. 为复杂设备（如 Speaker）实现建造者模式
4. 实现原型接口，使设备支持快速 clone
5. 确保 DeviceManager 是线程安全的单例
6. 提供控制台模拟用户选择厂商/设备并创建的交互界面



**技术提示**

- 使用接口 SmartDevice 作为设备抽象父类
- Light, AirConditioner, Speaker 作为子接口
- 每种厂商实现各自产品族
- 使用 Cloneable 实现原型
- 使用 enum 模拟用户选择



**示例输出**

欢迎使用智能家居系统

请选择设备类型：[Light]

请选择设备厂商：[Xiaomi]

 

数据：已创建设备：XiaomiLight（默认亮度80%，支持米家协议）

设备已注册到 DeviceManager

是否部署多个房间？Y

设备克隆成功：Room2 使用 XiaomiLight

设备克隆成功：Room3 使用 XiaomiLight