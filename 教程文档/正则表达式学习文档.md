# 正则表达式学习文档

## 目录

1. [什么是正则表达式？](https://www.google.com/search?q=%231-什么是正则表达式)
2. [为什么需要学习正则表达式？](https://www.google.com/search?q=%232-为什么需要学习正则表达式)
3. [基础入门](https://www.google.com/search?q=%233-基础入门)
   - [3.1 基本匹配](https://www.google.com/search?q=%2331-基本匹配)
   - [3.2 元字符 (Metacharacters)](https://www.google.com/search?q=%2332-元字符-metacharacters)
   - [3.3 字符集 (Character Sets)](https://www.google.com/search?q=%2333-字符集-character-sets)
   - [3.4 量词 (Quantifiers)](https://www.google.com/search?q=%2334-量词-quantifiers)
   - [3.5 贪婪与非贪婪匹配](https://www.google.com/search?q=%2335-贪婪与非贪婪匹配)
4. [进阶概念](https://www.google.com/search?q=%234-进阶概念)
   - [4.1 分组与捕获 (Grouping and Capturing)](https://www.google.com/search?q=%2341-分组与捕获-grouping-and-capturing)
   - [4.2 边界匹配 (Boundaries)](https://www.google.com/search?q=%2342-边界匹配-boundaries)
   - [4.3 或操作 (Alternation)](https://www.google.com/search?q=%2343-或操作-alternation)
   - [4.4 反向引用 (Backreferences)](https://www.google.com/search?q=%2344-反向引用-backreferences)
   - [4.5 零宽断言 (Lookarounds)](https://www.google.com/search?q=%2345-零宽断言-lookarounds)
5. [常用模式（备忘单）](https://www.google.com/search?q=%235-常用模式备忘单)
6. [常用工具与资源](https://www.google.com/search?q=%236-常用工具与资源)
7. [实践练习](https://www.google.com/search?q=%237-实践练习)

------



### 1. 什么是正则表达式？



正则表达式（Regular Expression，常简写为 regex 或 regexp）是一种强大的文本处理工具。它是一个由字符和特殊符号组成的序列，用于定义一个搜索模式。你可以用这个模式来匹配、查找、替换和验证字符串。

简单来说，正则表达式就是描述字符串模式的语言。



### 2. 为什么需要学习正则表达式？



- **强大的文本搜索能力**：可以在大量文本中快速、精确地找到你想要的内容。
- **高效的文本替换**：可以根据复杂的模式进行查找和替换，比简单的文本替换功能强大得多。
- **数据验证**：是验证用户输入（如邮箱、手机号、密码强度等）最常用的工具。
- **数据提取**：可以从日志文件、网页、API 响应等非结构化文本中提取出你需要的数据。
- **通用性**：几乎所有的编程语言（Python, JavaScript, Java, C++, Go, Ruby等）和许多文本编辑器（VS Code, Sublime Text等）、命令行工具（grep, sed, awk）都支持正则表达式。



### 3. 基础入门





#### 3.1 基本匹配



最简单的正则表达式就是普通字符，它会精确匹配自身。

- 正则表达式 `hello` 会匹配字符串 "hello world" 中的 "hello"。



#### 3.2 元字符 (Metacharacters)



元字符是正则表达式中具有特殊含义的字符，它们不代表自身，而是用于构建更复杂的模式。

| 元字符 | 名称       | 描述                                                         | 示例           | 匹配                   |
| ------ | ---------- | ------------------------------------------------------------ | -------------- | ---------------------- |
| `.`    | 点         | 匹配除换行符 `\n` 之外的任意单个字符。                       | `gr.y`         | "gray", "grey", "grby" |
| `\d`   | 数字       | 匹配任意一个数字 (0-9)。等价于 `[0-9]`。                     | `\d{3}`        | "123", "987"           |
| `\D`   | 非数字     | 匹配任意一个非数字字符。等价于 `[^0-9]`。                    | `\D`           | "a", " ", "&"          |
| `\w`   | 单词字符   | 匹配任意一个字母、数字或下划线。等价于 `[a-zA-Z0-9_]`。      | `\w{3}`        | "abc", "a_1", "123"    |
| `\W`   | 非单词字符 | 匹配任意一个非字母、数字或下划线的字符。等价于 `[^a-zA-Z0-9_]`。 | `\W`           | "!", " ", "@"          |
| `\s`   | 空白字符   | 匹配任意一个空白字符，包括空格、制表符 `\t`、换行符 `\n` 等。 | `hello\sworld` | "hello world"          |
| `\S`   | 非空白字符 | 匹配任意一个非空白字符。                                     | `\S+`          | "hello_world"          |
| `\`    | 转义符     | 将一个元字符转义为普通字符。                                 | `\.`           | 匹配字符 "." 本身      |



#### 3.3 字符集 (Character Sets)



使用方括号 `[]` 来定义一个字符集，它可以匹配括号中任意一个字符。

| 模式     | 描述                                                    | 示例                           |
| -------- | ------------------------------------------------------- | ------------------------------ |
| `[abc]`  | 匹配 "a"、"b" 或 "c" 中的任意一个字符。                 | `c[ae]t` 匹配 "cat" 和 "cet"。 |
| `[^abc]` | 否定字符集，匹配除了 "a"、"b"、"c" 之外的任意一个字符。 | `[^0-9]` 匹配任何非数字字符。  |
| `[a-z]`  | 范围，匹配从 "a" 到 "z" 的任意一个小写字母。            |                                |
| `[A-Z]`  | 范围，匹配从 "A" 到 "Z" 的任意一个大写字母。            |                                |
| `[0-9]`  | 范围，匹配从 "0" 到 "9" 的任意一个数字。                |                                |



#### 3.4 量词 (Quantifiers)



量词用来指定一个模式需要匹配的次数。

| 量词    | 描述                                 | 示例                                        |
| ------- | ------------------------------------ | ------------------------------------------- |
| `*`     | 匹配前一个元素 0 次或多次。          | `ab*c` 匹配 "ac", "abc", "abbbc"。          |
| `+`     | 匹配前一个元素 1 次或多次。          | `ab+c` 匹配 "abc", "abbbc"，但不匹配 "ac"。 |
| `?`     | 匹配前一个元素 0 次或 1 次。         | `colou?r` 匹配 "color" 和 "colour"。        |
| `{n}`   | 匹配前一个元素恰好 n 次。            | `\d{4}` 匹配一个四位数，如 "2025"。         |
| `{n,}`  | 匹配前一个元素至少 n 次。            | `\d{2,}` 匹配两位或更多位的数字。           |
| `{n,m}` | 匹配前一个元素至少 n 次，至多 m 次。 | `\w{6,12}` 匹配 6 到 12 个单词字符。        |



#### 3.5 贪婪与非贪婪匹配



默认情况下，量词 `*`, `+`, `{n,}` 都是“贪婪”的，它们会尽可能多地匹配字符。在量词后面加上一个 `?` 可以使其变为“非贪婪”模式，即尽可能少地匹配。

- **字符串**: `<div>hello</div><div>world</div>`
- **贪婪模式**: `<div>.*</div>` -> 匹配结果是 `<div>hello</div><div>world</div>` (匹配了从第一个 `<div>` 到最后一个 `</div>` 的所有内容)
- **非贪婪模式**: `<div>.*?</div>` -> 匹配结果是 `<div>hello</div>` 和 `<div>world</div>` (进行了两次匹配)



### 4. 进阶概念





#### 4.1 分组与捕获 (Grouping and Capturing)



使用圆括号 `()` 可以将多个字符作为一个整体进行处理，这被称为“分组”。

- **作用**:
  1. 对分组内的内容应用量词：`(ab)+` 匹配 "ab", "abab", "ababab" 等。
  2. 捕获匹配的内容：正则表达式 `(\d{4})-(\d{2})-(\d{2})` 用于匹配日期 "2025-08-20"，括号会分别捕获 "2025"、"08" 和 "20"，这些捕获的内容可以在后续处理中使用。
- **非捕获分组**: 如果你只想使用分组的量词功能而不需要捕获其内容，可以使用 `(?:...)`。例如 `(?:ab)+`。这在复杂正则表达式中可以提高效率。



#### 4.2 边界匹配 (Boundaries)



边界匹配符用于匹配字符串中的特定位置，而不是字符本身。

| 边界 | 名称       | 描述                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| `^`  | 行首       | 匹配字符串的开始位置。                                       |
| `$`  | 行尾       | 匹配字符串的结束位置。                                       |
| `\b` | 单词边界   | 匹配一个单词的开始或结束位置。例如，`\bcat\b` 会匹配 "cat"，但不会匹配 "concat"。 |
| `\B` | 非单词边界 | 匹配非单词边界的位置。                                       |



#### 4.3 或操作 (Alternation)



使用 `|` 符号可以实现“或”逻辑，即匹配 `|` 左右两边的任意一个模式。

- `cat|dog` 匹配 "cat" 或 "dog"。
- 注意与字符集 `[]` 的区别：`[cd]` 只匹配单个字符 "c" 或 "d"，而 `c|d` 也是如此。但 `cat|dog` 匹配的是整个单词。



#### 4.4 反向引用 (Backreferences)



当使用分组 `()` 捕获了文本后，可以使用 `\1`, `\2` 等来引用第一个、第二个捕获组匹配到的内容。

- `(\w+)\s+\1` 可以匹配重复的单词，如 "hello hello"。`\1` 引用了第一个括号 `(\w+)` 捕获到的内容。



#### 4.5 零宽断言 (Lookarounds)



零宽断言用于匹配某个位置，这个位置需要满足某些条件，但这些条件本身并不会被包含在最终的匹配结果中。它们“零宽度”，不消耗任何字符。

| 断言       | 名称         | 描述                                                     |
| ---------- | ------------ | -------------------------------------------------------- |
| `(?=...)`  | 正向先行断言 | 匹配一个位置，该位置后面紧跟着的字符序列需要匹配 `...`。 |
| `(?!...)`  | 负向先行断言 | 匹配一个位置，该位置后面紧跟着的字符序列不能匹配 `...`。 |
| `(?<=...)` | 正向后行断言 | 匹配一个位置，该位置前面紧跟着的字符序列需要匹配 `...`。 |
| `(?<!...)` | 负向后行断言 | 匹配一个位置，该位置前面紧跟着的字符序列不能匹配 `...`。 |

**示例**：

- 从 "Windows 10", "Windows 7" 中只提取出 "Windows"。
  - 正则表达式：`Windows(?=\s\d+)`
  - 解释：匹配 "Windows"，条件是它后面跟着一个空格和若干数字。
- 从 "$120" 和 "€50" 中只提取出数字 "120"。
  - 正则表达式：`(?<=\$)\d+`
  - 解释：匹配若干数字，条件是它前面是一个美元符号 `$`。



### 5. 常用模式（备忘单）



- **邮箱地址**: `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`
- **URL**: `https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)`
- **中国大陆手机号**: `^1[3-9]\d{9}$`
- **IP 地址 (IPv4)**: `\b(?:\d{1,3}\.){3}\d{1,3}\b`
- **整数**: `^-?\d+$`
- **正整数**: `^\d+$`
- **日期 (YYYY-MM-DD)**: `^\d{4}-\d{2}-\d{2}$`



### 6. 常用工具与资源



学习正则表达式最好的方法就是不断练习。以下是一些非常有用的在线工具：

- **Regex101**: https://regex101.com/
  - 功能强大的在线测试工具，可以实时看到匹配结果，并提供详细的匹配过程解释，支持多种语言的正则引擎。强烈推荐！
- **RegExr**: https://regexr.com/
  - 界面非常友好的测试工具，包含社区分享的常用表达式。
- **MDN Web Docs (JavaScript)**: [Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions)
  - 如果你主要在前端或 Node.js 环境下使用，MDN 的文档非常权威和详尽。



### 7. 实践练习



尝试使用你学到的知识，为你自己的需求编写正则表达式，并在 [Regex101](https://regex101.com/) 上进行测试。

1. **练习 1**: 验证一个密码是否至少有 8 位，并且同时包含大写字母、小写字母和数字。
2. **练习 2**: 从一段 HTML 文本中，提取出所有 `<h1>` 标签的内容。
   - 例如，从 `<h1>Title 1</h1><p>text</p><h1>Title 2</h1>` 中提取 "Title 1" 和 "Title 2"。
3. **练习 3**: 匹配所有以 ".jpg" 或 ".png" 结尾的文件名。
4. **练习 4**: 从日志文件中提取所有日期为 "2025-08-20" 的行。